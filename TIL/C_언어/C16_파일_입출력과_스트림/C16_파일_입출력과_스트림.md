# Chapter16 스트림과 파일 입출력

### 학습목표

* 스트림의 개념을 이해한다.
* 형식화된 입출력을 이해한다.
* 파일 입출력을 이해한다.
* 입출력 라이브러리 함수들을 이해한다.

## 16.1 스트림

일반적으로 프로그램에서는 화면이나 키보드, 파일 등의 입출력 장치에 대하여 데이터를 읽거나 쓰게 되는데 C언어에서는 스트림이라는 개념을 사용하여서 일관된 방법으로 입출력을 수행할 수 있다.

**스트림이란 모든 입력과 출력을 바이트(byte)들의 흐름으로 생각하는 것이다.**

* 특징

  * 장치독립성

    입력과 출력이 연속적인 바이트의 스트림이기 때문에 입출력장치에 상관없이 프로그램을 작성할 수 있다.

  * 버퍼의 사용

    CPU의 연산속도가 입출력 장치보다 훨씬 빠르기 때문에 입출력장치를 CPU가 기다리는 것은 비효율적이다. 그래서 입력시 버퍼에 데이터를 쌓아놓고 CPU가 연산을 하고, 또 결과도 버퍼에 저장해놓았다가 한번에 출력한다.

### 표준 입출력 스트림

몇 개의 기본적인 스트림들은 프로그래머가 생성하지 않아도 자동으로 생성된다.

|  이름  |      스트림      |   연결장치    |
| :----: | :--------------: | :-----------: |
| stdin  | 표준 입력 스트림 |    키보드     |
| stdout | 표준 출력 스트림 | 모니터의 화면 |
| stderr | 표준 오류 스트림 | 모니터의 화면 |

### 입출력 함수의 분류

입출력 함수들은 사용하는 스트림과 입출력 형식이 지정되느냐 않느냐에 따라 분류할 수 있다.

| 형식 / 스트림                         | 표준 스트림 | 일반 스트림           | 설명               |
| ------------------------------------- | ----------- | --------------------- | ------------------ |
| 형식이 없는 입출력 ( 문자 형태 )      | getchar()   | fgetc(FILE *f, ...)   | 문자 입력 함수     |
|                                       | putchar()   | fputc(FILE *f, ...)   | 문자 출력 함수     |
|                                       | gets()      | fgets(FILE *f, ...)   | 문자열 입력 함수   |
|                                       | puts()      | fputs(FILE *f, ...)   | 문자열 출력 함수   |
| 형식이 있는 입출력 ( 정수, 실수 ... ) | printf()    | fprintf(FILE *f, ...) | 형식화된 출력 함수 |
|                                       | scanf()     | fscanf(FILE *f, ...)  | 형식화된 입력 함수 |

* 형식이 있는 입출력은 정수나 실수 등 데이터의 형식을 지정하는 입출력을 의미한다.

## 16.2 printf() 출력

```c
int printf(char *format, ...); // 형식

printf("%10d %20.3f\n", index, value); // 예제, 표준 출력 스트림(콘솔)에 데이터를 출력한다.
```

### 형식 제어 문자열

printf()에 첫 번째 매개변수인 format은 형식 제어 문자열이라고 불린다. 형식 제어 문자열은 변수나 수식의 값을 출력하는 형식을 지정한다.

형식 제어 문자열에서 필수적으로 있어야 하는 것은 **'형식'**뿐이다.  다른 것들은 선택 사항이다.

```c
%[플래그][필드폭][.정밀도] 형식
```

#### 플래그(flag)

플래그는 하나의 문자로서 출력의 정렬과 부호 출력, 공백 출력, 8진수와 16진수 접두사 출력 등을 지시한다.

| 기호       | 의미                                                         | 기본값                       |
| ---------- | ------------------------------------------------------------ | ---------------------------- |
| -          | 출력 필드에서 출력값을 왼쪽 정렬한다.                        | 오른쪽 정렬된다.             |
| +          | 결과 값을 출력할 때 항상 +와 -의 부호를 붙인다.              | 음수일 때만 - 부호를 붙인다. |
| 0          | 출력값 앞에 공백문자 대신 0으로 채운다.                      | 채우지 않는다.               |
| blank(' ') | 출력값 앞에 양수나 영인 경우 부호 대신 공백을 출력한다.      | 공백을 출력하지 않는다.      |
| #          | 8진수 출력 시에는 출력값 앞에 0을 붙이고 16진수 출력시에는 0x를 붙인다. | 붙이지 않는다.               |

#### 필드폭(width)과 정밀도(precision)

데이터가 출력되는 필드의 크기를 지정할 수 있다. 출력 값이 필드 폭보다 더 적은 개수의 문자로 출력된다면 스페이스가 덧붙여지고 더 많은 문자를 필요로 한다면 필드가 확장된다.

필드폭은 %와 형식 지정자 사이에 들어간다.

정밀도는 필드폭과 형식 지정자 사이에 .과 함께 들어간다.

```c
printf("%10.3d", 123.123456); // 예제. 폭은 10, 소숫점 이하 3자리까지 출력.
// 결과:   123.123
```

#### 형식

| 형식 지정자 | 설명                                          | 출력 예    |
| ----------- | --------------------------------------------- | ---------- |
| %d          | 부호 있는 10진수 형식으로 출력                | 255        |
| %i          | 부호 있는 10진수 형식으로 출력                | 255        |
| %u          | 부호 없는 10진수 형식으로 출력                | 255        |
| %o          | 부호 없는 8진수 형식으로 출력                 | 377        |
| %x          | 부호 없는 16진수 형식으로 출력, 소문자로 표기 | fe         |
| %X          | 부호 없는 16진수 형식으로 출력, 대문자로 표기 | FE         |
| %f          | 소숫점 고정 표기 형식으로 출력                | 123.456    |
| %e          | 지수 표기 형식으로 출력 지수 부분을 e로 표시  | 1.23456e+2 |
| %E          | 지수 표기 형식으로 출력 지수 부분을 E로 표시  | 1.23456E+2 |
| %g          | %e 형식과 %f 형식 중 더 짧은 형식으로 출력    | 123.456    |
| %G          | %E 형식과 %f 형식 중 더 짧은 형식으로 출력    | 123.456    |
| %p          | 포인터 형식으로 출력                          | 0027FDDO   |

실수를 표기하는 방법에는 두가지 방법이 있다.

* 정수부와 소수부를 나눠서 표기

  %f가 여기에 해당되고 정수부와 실수부를 나눠서 표기한다.

* 과학적 표기법으로 표기

  %e, %E가 여기에 해당되고 실수를 가수와 지수로 분리하여 표기한다.

## 16.3 scanf()를 이용한 입력

scanf()는 표준 입력에서 어떤 형식(format)을 지정하여 데이터를 받아들이는 함수이다. getchar()나 gets()와는 다르게 문자열을 숫자의 형태로 자동적으로 변환시켜 주므로 편리하다.

scanf()는 문자열을 정수, 실수로 변환하는 역할을 한다.

```c
int scanf(char *format, ...); // 형식

scanf("%d", &value); // 예제. 표준 입력 스트림(키보드)에서 데이터를 입력한다. 읽은 항목의 수를 반환한다.
```

형식 제어 문자열 format은 <u>사용자로부터 받은 문자열을 변환하는 형식을 지정한다.</u> 형식 제어 문자열에는 플래그, 필드 넓이, 형식 지정자 등을 가질 수 있다.

scanf()는 사용자가 입력하는 문자열을 공백문자(줄바꿈, 탭, 스페이스)로 분리하여 각각의 형식 지정자에 연결시킨다.

### 필드폭 지정하여 읽기

형식 제어 문자열에 필드폭이 지정되었으면 필드폭 만큼의 문자를 읽어서 값으로 변환한다.

```c
scanf("%3d%3d", &a, &b); // 123456을 입력하면 a, b에 각각 123, 456이 저장된다.
```

### 8진수, 16진수 입력

형식 제어 문자열에 형식 지정자가 다르면 서로 다른 값이 변수에 저장된다.

```c
scanf("%d %o %x", &a, &b, &c); // 각 문자열에 10을 대입해도 %d는 10, %o는 8 %x는 16의 변수를 저장한다.
printf("d=%d o=%d x=%d", a, b, c);
```

### 문자와 문자열 읽기

| 분류   | 형식 지정자 | 설명                                                         |
| ------ | ----------- | ------------------------------------------------------------ |
| 문자형 | %c          | char형으로 입력받는다.                                       |
|        | %s          | 공백 문자가 아닌 문자부터 공백 문자가 나올 때까지를 문자열로 변환하여 입력받는다. |
|        | %[abc]      | 대괄호 안에 있는 문자 a, b, c로만 이루어진 문자열을 읽어 들인다. |
|        | %\[^abc]    | 대괄호 안에 있는 문자 a, b, c만을 제외하고 다른 문제들로 이루어진 문자열을 읽어들인다. |
|        | %[0-9]      | 0에서 9까지의 범위에 있는 문자들로 이루어진 문자열을 읽어 들인다. |

scanf()로 문자를 읽을때는 형식 지정자 %c를 이용해서 읽는다. 문자를 읽는 경우 형식지정자가 붙어 있는지, 떨어져 있는지에 따라 결과가 달라진다.

* 형식 지정자 사이에 공백 문자가 있는 경우

  공백 문자를 이용하여 문자들을 분리한다.

* 형식 지정자들이 붙어 있는 경우

  공백 문자도 하나의 문자로 취급되어 입력된다.

문자열은 %s로 읽어서 char형 배열에 저장한다.

### 문자 집합으로 읽기

scanf()에는 **문자 집합을 기호로 표시하고 이 문자 집합에 포함된 문자만을 읽을 수 있는 기능이 들어 있다.**

읽고 싶은 문자 집합은 문자들을 대괄호[ ]로 묶어서 표시한다.

```c
scanf("%[abc]", s); // a,b,c로 이루어진 문자열만 받음.
```

###  scanf()의 반환값 이용

scanf()가 반환하는 값을 읽은 항목의 개수이다. 따라서 이것을 이용하면 사용자가 값을 몇 개나 성공적으로 입력하는였는지 검사할 수 있다.

```c
if (scanf("%d%d%d", &x, &y, &z) == 3)
    printf("정수들의 합은 %d\n", x+y+z);
else
    printf("입력값이 올바르지 않습니다.");
```

### fflush()의 사용

만약 scanf()를 사용하여서 입력을 처리할 때 이전에 입력되었던 값들이 버퍼에 남아 있어서 방해가 된다면 fflush(stdin) 함수를 호출하면 된다.

```c
scanf("%c", &ch);
fflush(stdin);
printf("%d ", ch);
```

## 16.4 파일의 기초

여태까지 대부분의 예제 프로그램은 표준 입력인 키보드와 표준 출력인 모니터를 사용하였다. 하지만 **실제 응용 프로그램에서는 데이터나 현재의 설정 정보를 저장하기 위하여 디스크에 저장되는 파일을 많이 사용한다.**

파일을 사용하면 데이터를 영구적으로 보관할 수 있다. C에서는 디스크에 파일을 생성시켜서 데이터를 보관할 수 있다.

### 파일의 개념

C에서의 모든 입출력은 스트림을 통하여 이루어진다. 파일도 마찬가지로 스트림으로 취급되어 일련의 연속된 바이트로 생각할 수 있기 때문에 파일에 대한 입출력도 표준 입출력과 동일한 함수들로 이루어진다.

파일 입출력을 위해서는 프로그래머가 파일 이름을 직접 결정하여 파일 스트림을 생성하여야 한다.

모든 파일은 입출력 동작이 발생하는 현재 위치를 나타내는 **파일 포인터(file pointer)를 가지고 있다.** 파일을 처음으로 열면 파일 포인터는 첫 번째 바이트를 가리킨다. 입출력 연산이 진행되면 파일 포인터가 자동적으로 이동된다.

### 파일의 유형

C에서는 텍스트 파일(text file)과 이진 파일(binary file)의 두 가지 파일 유형을 지원한다.

* 텍스트파일

  사람이 읽을 수 있는 텍스트가 들어 있는 파일이다. 메모장이나 소스 파일이 텍스트 파일의 예이다.

  * 문자들이 들어있고 아스키 코드를 이용하여 표현된다.
  * **텍스트 파일은 모니터, 키보드, 프린터등이 모두 문자 데이터만을 처리하기 때문에 중요하다.**
  * 텍스트 파일은 연속적인 줄(line)들로 구성된다.
    * 텍스트 파일에서는 문자열의 끝을 나타내는데 NULL문자를 사용하지 않는다. 대신 줄의 끝을 표시하기 위해여 \n을 사용한다.
    * 윈도우는 캐리지 리턴(\r)과 줄바꿈 문자(CR-LF)의 조합으로 이루어진다.

* 이진 파일

  사람이 읽을 수 없으나 컴퓨터는 읽을 수 있는 파일이다. 문자 데이터가 아니라 이진 데이터가 직접 저장되어 있는 파일이다. 실행 파일, 사운드 파일, 이미지 파일 등이 이진 파일의 예이다.

  * 이진 파일은 텍스트 파일과 달리, 줄들로 분리되지 않는다. 모든 데이터들은 문자열 형태가 아진, 이진수 형태로 저장된다.
  * **이진 파일은 특정 프로그램에 의해서만 판독이 가능하다.**
  * 텍스트 파일처럼 한 줄이라는 개념이 없기 때문에 줄의 끝을 표시할 필요가 없으며 <u>NULL이나 CR, LF와 같은 문자들도 특별한 의미를 가지지 않고 단순히 데이터로 취급</u>된다.

### 파일 처리의 개요

프로그램에서 **파일을 연다(open)**는 것은 파일에서 데이터를 읽거나 쓸 수 있도록 모든 준비를 마치는 것을 의미한다. **내부적으로는 파일과 연결된 스트림을 만들게 된다.** 파일을 열면 데이터를 읽고, 쓸 수 있다.

파일을 사용한 후에는 파일을 닫아야(close)한다.

* '파일 열기 - 파일 읽기와 쓰기 - 파일 닫기' 순서를 지켜야한다.

### 파일 열기

파일을 열려면 라이브러리 함수를 사용해야 한다.

```c
FILE *fopen (const char *name, const char *mode); // 형식 매개변수는 각각 파일의 이름, 파일의 모드를 가리킴
// name이라는 이름을 가지는 파일을 mode에 지정된 모드로 연다. FILE 포인터를 변환한다.

FILE *fp;
fp = fopen("test.txt", "w"); // 예제. test.txt라는 이름을 가지는 파일을 쓰기모드로 연다.
```

* 기본적인 파일모드

  * "r" : 읽기모드

    읽기 작업을 위해 파일을 여는 것이다.

  * "w" : 쓰기모드

    데이터를 쓰기 위해 파일을 여는 것이다.

  * "a" : 추가모드

    파일이 없으면 새로운 파일을 만들고, 파일이 있으면 끝에 추가한다.

* 파일모드 표 정리

  | 모드 | 설명                                                         |
  | ---- | ------------------------------------------------------------ |
  | "r"  | 읽기 모드로 파일을 연다. 만약 파일이 존재하지 않으면 오류가 발생한다. |
  | "w"  | 쓰기 모드로 새로운 파일을 생성한다. 파일이 이미 존재하면 기존의 내용이 지워진다. |
  | "a"  | 추가 모드로 파일을 연다 만약 기존의 파일이 있으면 데이터가 파일의 끝에 추가된다. 파일이 없으면 새로운 파일을 만든다. **파일이 절대 지워지지 않는다.** |
  | "r+" | 읽기 모드로 파일을 연다. 쓰기 모드로 전환할 수 있다. 파일이 반드시 존재해야 한다. |
  | "w+" | 쓰기 모드로 새로운 파일을 생성한다. 읽기 모드로 전환할 수 있다. 파일이 이미 존재하면 기존의 내용이 지워진다. |
  | "a+" | 추가 모드로 파일을 연다. 읽기 모드로 전환할 수 있다. 데이터를 추가하면 EOF 마커를 추가된 데이터의 뒤로 이동한다. 파일이 없으면 새로운 파일을 만든다. **파일이 절대 지워지지 않는다.** |
  | "t"  | 텍스트 파일 모드로 파일을 연다.                              |
  | "b"  | 이진 파일 모드로 파일을 연다.                                |

  * 기본적인 파일 모드에  "t", "b"를 붙여서 "rb"형식으로 쓸수도 있고, 붙이지 않은 경우 텍스트파일로 간주한다.
  * 모드를 전환할 수 있을 때 전환하려면 fflush(), fsetpos(), fseek(), rewind() 중 하나의 함수를 사용하여야 한다.

### 파일 닫기

열린 파일을 닫는 함수는 fclose이다. fclose()는 stdio.h에 정의되어 있다.

```c
int fclose(FILE *stream); // 형식. stream에 의하여 지정된 파일을 닫는다.

FILE *fp; // 예제
fp = fopen("test.txt", "w");
fclose(fp);
```

* 성공적으로 파일을 닫는 경우 0이 반환된다. 실패한 경우 -1이 반환된다.

### 파일 삭제

파일을 삭제하는 함수는 remove()이다. remove()는 stdio.h에 정의되어 있다.

```c
remove("sample.txt"); // 예제. 파일 sample.txt를 삭제한다.
```

* 성공적으로 파일을 삭제하는 경우 0이 반환되고 실패하는 경우 -1이 반환된다.

### 기타 유용한 함수들

| 함수                                                 | 설명                                                         |
| ---------------------------------------------------- | ------------------------------------------------------------ |
| int foef(FILE *stream)                               | 파일에 끝에 도달되면 true를 반환한다.                        |
| int rename(const char *oldname, const char *newname) | 파일의 이름을 변경한다.                                      |
| FILE *tmpfile()                                      | 임시 파일을 생성하여 반환한다.                               |
| int ferror(FILE *stream)                             | 스트림의 오류 상태를 반환한다. 오류가 발생하면 true가 반환된다. |

## 16.5 텍스트 파일 읽기와 쓰기

파일을 열었으면 프로그램에서는 파일에서 데이터를 읽을 수도 있고 쓸 수도 있다.

* 파일 입출력에 관계되는 라이브러리 함수

| 종류            | 입력 함수                                                 | 출력 함수                                                  |
| --------------- | --------------------------------------------------------- | ---------------------------------------------------------- |
| 문자 단위       | int fgetc(FILE *fp)                                       | int fputc(int c, FILE *fp)                                 |
| 문자열 단위     | char *fgets(char *buf, int n, FILE *fp)                   | int fputs(const char *buf, FILE *fp)                       |
| 서식화된 입출력 | int fscanf(FILE *fp)                                      | int fprintf(FILE *fp, ...)                                 |
| 이진 데이터     | size_t fread(char *buffer, int size, int count, FILE *fp) | size_t fwrite(char *buffer, int size, int count, FILE *fp) |

*  문자, 문자열 단위의 입출력

  문자, 문자열 단위의 입출력은 파일에 사람들이 읽을 수 있는 텍스트 형태로 데이터를 저장하는 것이고 **텍스트 파일에서만 가능하다.**

  * 함수의 반환값은 성공적으로 읽은 항목의 수를 반환하므로 반환값이 0이면 입출력이 실패했음을 의미한다.
  * 입출력이 실패하는 이유는 오류가 발생했을수도 있고, 파일이 끝났을수도 있다.
    * 오류가 발생하는 경우  feof()나 ferror()를 호출하면 된다.

* 서식화된 입출력

  서식화된 입출력은 입출력 형식을 지정하여 파일에 그 형식으로 데이터를 저장할 수 있다. **텍스트 파일에서만 가능하다.**

  * 텍스트와 숫자가 포함된 데이터를 정해진 형식으로 파일에 기록하는데 사용한다.

* 이진 데이터 입출력

  이진 데이터 입출력은 메모리에 있는 데이터를 직접 디스크 파일에 그대로 저장하는 것이다.**이진 파일에서만 가능하다.**

  * 전용 프로그램에서 나중에 사용하기 위한 데이터를 저장하기 위해서 사용한다.

### 문자 단위 입출력

fputc()를 이용해서 텍스트 파일을 생성할 수 있다.

* fputc.c Code

  ```c
  #include <stdio.h>
  
  int main(void)
  {
      FILE *fp = NULL;
      fp = fopen("sample.txt", "w");
      if( fp == NULL )
          printf("file open fail\n");
      else
          printf("file open success\n");
      fputc('a', fp);
      fputc('b', fp);
      fputc('c', fp);
      fclose(fp);
      return 0;
  }
  ```

  * sample.txt 파일에 abc가 저장되어 있다.

fgetc()를 이용해서 텍스트 파일의 내용을 화면에  표시할 수 있다.

* fgetc.c Code

  ```c
  #include <stdio.h>
  
  int main(void)
  {
      FILE *fp = NULL;
      int c;
  
      fp = fopen("sample.txt", "r");
      if( fp == NULL )
          printf("file open fail.\n");
      else
          printf("file open success.\n");
      while((c = fgetc(fp)) != EOF)
          putchar(c);
      fclose(fp);
      return 0;
  }
  ```

  * 실행 결과 파일을 열고 abc를 출력한다.

### 문자열 단위 입출력

