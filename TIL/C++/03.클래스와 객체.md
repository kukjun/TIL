

세상 모든 것을 객체라고 할 수 있다.

# 객체지향 프로그램 특성

* 캡슐화(encapsulation)
  : 자료와 이를 조작하는 코드를 결합하여 외부의 간섭과 오용으로 부터 코드와 자료를 안전하게 유지하는 것

  * 비공개 코드나 자료 : 내부에서만 알수있고 접근 가능
  * 공개 자료 : 객체 외부에서 접근이 가능
    
* 비공개부를 통체하기 위한 인터페이스를 제공
    
* 목적
  
  객체 내 데이터에 대한 **보안, 보호, 외부 접근 제한**
  
* 다형성(Polymorphism)
  : "많은(poly)- 형태(morph)"를 뜻하는 그리스어에서 유래

  하나의 이름이 목적은 다르지만 관련이 있는 두 가지 이상의 용도로 사용될 수 있도록 하는 특징

  * **함수 다중 정의 (Function overloading)**
    : 서로 다른 자료형을 처리하는 같은 이름의 함수를 각각 정의할 수 있다.
  * **연산자 다중 정의 (operator overloading)**
    : C++에서는 사용자 정의 자료형에서도 적용할 수 있도록 확장

* 상속성 (Inheritance)
  : 한 객체가 다른 객체의 특성을 이어받는 과정이다.

  * 한 객체는 일반적인 특성들을 상속받아서 다시 자신만의 특성을 추가할 수 있다.
  * 객체를 일반특성과 유일 특성을 분리기술이 가능
  * 계층적 클래스화(hierarchical classification)의 개념을 지원

# 클래스

객체를 만들어내기 위해 정의된 설계도, 틀
**클래스는 객체가 아니고, 실체하지 않는다.**

* ex

  TV

  * 상태 (state)

    on/off 속성 - 현재 작동 중인지 표시
    채널 - 재 방송중인 채널
    음량 - 현재 출력되는 소리 크기

  * 행동 (behavior)

    켜기, 끄기
    채널 증가, 채널 감소
    음량 증가, 음량 감소

## C++ 클래스

클래스는 **선언부와 구현부로 구성**된다.

### 클래스 선언부

class 키워드를 이용하여 클래스 선언
**맴버 변수와 맴버 함수 선언**

* 맴버 변수는 클래스 선언 내에서 초기화 할 수 없다.
* 맴버 함수는 원형(prototype) 형태로 선언

멤버에 대한 접근 권한 지정

* private, public, protected 중 하나로 지정, 디폴트는 private
  * public : 다른 모든 클래스나 객체에서 멤버의 접근이 가능함을 표시

##### Syntax

```C++
class <class_name> {
    public:
    int variable; // 멤버 변수
    double function(); // 멤버 함수
}
```

<br>

### 클래스 구현부

클래스에 선언된 모든 멤버 함수 구현

##### Syntax

```c++
double <calss_name> :: function() {
    // 순서대로 함수 리턴 타입, 클래스 이름, 범위지정 연산자, 멤버 함수명과 매개변수
    return <return type>
}
```

<br>

### 생성자와 소멸자

생성자(constructor)는 클래스의 객체가 생성될 때 수행되고, 소멸자(destructor)는 객체의 사용이 끝났을 때 수행되는 특별한 형태의 멤버 함수이다. (생성자 함수, 소멸자 함수)

* 클래스 정의 시 생성자와 소멸자를 정의하지 않으면 컴파일러가 기본 생성자와 기본 소멸자를 만든다.
  * 생성과 소멸 시 특별한 처리를 위해서는 사용자가 직접 생성자와 소멸자를 기술

#### 생성자 함수의 특징

생성자 함수는 **객체가 생성될 때 객체가 필요한 멤버 변수 초기화를 위해 사용한다.**

* 생성자 이름은 반드시 클래스 이름과 동일

* 생성자는 리턴 타입을 선언하지 않는다.

  * void 타입도 안된다.

* 객체 생성 시 오직 한 번만 호출

  자동으로 호출되고 임의로 호출할 수 없음. 각 객체가 만들어질때마다 생성자 실행

* 생성자는 중복 가능

  * 생성자는 한 클래스 내에 여러 개 가능
  * 중복된 생성자 중 하나만 실행
    * 매개변수 개수로 구분

* 생성자가 선언되어 있지 않으면 기본 생성자가 매개변수가 없는 생성자로 자동 생성

  * 기본 생성자 - 아무것도 하지 않고 종료
    * **생성자가 이미 있는 경우 기본 생성자를 만들지 않음**

##### Syntax

```C++
class <class_name> {
    public:
    int variable; // 멤버 변수
    double function(); // 멤버 함수
    class_name(); // 생성자
    class_name(int r) // 매개변수 있는 생성자
}
<calss_name> :: class_name() { // 생성자 클래스 구현부
    // 멤버 변수 초기화 실행
    // 객체 생성 시 수행될 내용 작성
}
<calss_name> :: class_name(int r) { // 매개변수 있는 생성자 클래스 구현부
    // 멤버 변수 초기화 실행
	// 객체 생성 시 수행될 내용 작성
}
```

<br>

#### 소멸자 함수의 특징

소멸자 함수는 객체가 사라질때 마무리 작업을 하기 위해 필요하다.

* 동적 메모리 할당 해제 등등

* 소멸자 함수의 이름은 클래스 이름 앞에 ~를 붙인다.
* 리턴 타입이 없고 리턴하면 안된다.
* 소멸자는 중복될 수 없다.
  * 오직 한 클래스에 하나만 작성 가능
* 소멸자가 선언되어 있지 않으면 기본 소멸자가 자동으로 생성
  * 기본 소멸자 - 아무것도 하지 않고 종료

##### Syntax

```C++
class <class_name> {
    public:
    int variable; // 멤버 변수
    double function(); // 멤버 함수
    ~class_name(); // 소멸자
}
<calss_name> :: ~class_name() { // 소멸자 클래스 구현부
    // 객체 소멸 시 수행될 내용 작성
}
```

<br>

<br>

# 객체

**객체는 상태(state)와 행동(behavior)으로 구성**

객체는 **클래스의 모양을 그대로 가지고 생성**
멤버 변수와 맴버 함수로 구성

메모리에 생성, 실체(instance)라고도 부름

하나의 클래스 틀에서 찍어낸 **여러 개의 객체 생성 가능**
객체들은 상호 별도의 공간에서 생성

* ex

  TV - LG

  * 상태 (state)

    on/off 속성 - 현재 작동 중인지 표시
    채널 - 재 방송중인 채널
    음량 - 현재 출력되는 소리 크기

  * 행동 (behavior)

    켜기, 끄기
    채널 증가, 채널 감소
    음량 증가, 음량 감소

  C++로 설계된 TV 객체

  * 맴버 변수
  * 맴버 함수

## C++ 객체

**객체는 클래스 타입의 객체가 생성된다.**

##### Syntax

* 객체 이름 및 객체 생성

  ```C++
  <class_name> <object_name> // 객체가 생성되면 메모리가 할당된다.
  ```

* 객체의 멤버 변수 접근

  ```C++
  <object_name>.<various> // 객체
  ```

* 객체의 멤버 함수 접근

  ```C++
  <object_name>.<function()>
  ```

<br>

### 객체 생성자, 소멸자 순서

* 객체 선언 위치에 따른 분류
  * 지역 객체
    : 함수 내에 선언된 객체로서, 함수가 종료하면 소멸된다.
  * 전역 객체
    : 함수의 바깥에 선언된 객체로서, 프로그램이 종료할 때 소멸된다.
* 객체 생성 순서
  * 전역 객체는 프로그램에 선언된 순서로 생성
  * 지역 객체는 함수가 호출되는 순서대로 생성
* 객체 소멸 순서
  * 함수가 종료하면 지역 객체가 **생성된 순서의 역순으로 소멸**
  * 프로그램이 종료하면 전역 객체가 **생성된 순서의 역순으로 소멸**
* new를 이용해 동적으로 생성된 객체의 경우
  * new를 실행하는 순간 객체 생성
  *  delete 연산자를 실행할 때 객체 소멸

## 접근 지정자

### 캡슐화의 목적

* 객체의 상태를 나타내는 데이터(멤버 변수)에 대한 보호
* 중요한 멤버는 다른 클래스나 객체에서 접근할 수 없도록 보호
* 외부와의 인터페이스를 위해서 일부 멤버는 외부에 접근 허용

멤버에 대한 접근 지정자는 3가지가 있다.

* private
  : 동일한 클래스의 멤버 함수에만 허용함
* public
  : 모든 다른 클래스에 허용
* protected
  : 클래스 자신과 상속받은 자식 클래스에만 허용

**일반적으로 멤버 변수는 private으로 지정하는 것이 바람직하다**

## 인라인 함수

함수 호출에 대한 시간 오버헤드가 너무 크기 때문에 만들어진 함수.

* inline 키워드로 선언
* 인라인 함수를 호출하는 곳에 인라인 함수 코드를 확장 삽입
  * 메크로와 유사
  * 코드 확장 후 인라인 함수는 사라짐
* 컴파일러에 의해 이루어짐

#### 장점

함수 호출에 따른 오버헤드가 존재하지 않음

프로그램 실행 속도 개선

* **자주 호출되는 짧은 코드의 함수 호출에 대한 시간 소모를 줄임**

#### 단점

인라인 함수 코드의 삽입으로 코드 길이 증가

* 짧은 길이의 함수만 인라인 함수로 선언

##### Syntax

```C++
inline <return_type> <function()> { // 함수 선언과 동일하고, 앞에 inline만 붙여준다.

}
```

* 함수 내부에서 컴파일러에 의해  lnline 함수의 코드 확장 삽입이 이루어진다.

### 자동 인라인 함수

클래스 선언부에 구현된 멤버 함수

* lnline으로 선언할 필요 없음
* 컴파일러에 의해 자동으로 인라인 처리
* 생성자를 포함한 모든 함수가 자동 인라인 함수 가능

# 바람직한 C++ 작성법

클래스를 헤더 파일과 cpp파일로 분리하여 작성

* 클래스마다 분리 저장
* 클래스 선언부는 헤더 파일(.h)에 저장
* 클래스 구현부는 cpp 파일에 저장
  * 클래스가 선언된 헤더 파일을 포함(include)
* main() 등 전역 함수나 변수는 다른 cpp 파일에 분산 저장
  * 필요하면 클래스가 선언된 헤더 파일 include

**이런 방식으로 하면 클래스 재사용이 가능하다.**

## 헤더 파일의 중복 include

헤더 파일을 중복 include 할 때 생기는 문제

* 주로 2개 이상의 컴파일된 파일을 링킹해 실행파일로 만들때 생기는 문제이다.

**헤더 파일에 조건 컴파일을 사용해 해결한다.**

##### Syntax

* 헤더 파일(.h)

  ```C++
  #ifndef classname_H // 조건 컴파일 문의 상수는 다른 조건 컴파일 상수와 충돌을 피하기 위해 클래스 이름으로 하는 것이 좋다.
  #define classname_H
  
  class <classname> {
      
  }
  
  #endif
  ```