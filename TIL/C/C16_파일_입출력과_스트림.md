# Chapter16 스트림과 파일 입출력

### 학습목표

* 스트림의 개념을 이해한다.
* 형식화된 입출력을 이해한다.
* 파일 입출력을 이해한다.
* 입출력 라이브러리 함수들을 이해한다.

<br>

## 16.1 스트림

일반적으로 프로그램에서는 화면이나 키보드, 파일 등의 입출력 장치에 대하여 데이터를 읽거나 쓰게 되는데 C언어에서는 스트림이라는 개념을 사용하여서 일관된 방법으로 입출력을 수행할 수 있다.

**스트림이란 모든 입력과 출력을 바이트(byte)들의 흐름으로 생각하는 것이다.**

* 특징

  * 장치독립성

    입력과 출력이 연속적인 바이트의 스트림이기 때문에 입출력장치에 상관없이 프로그램을 작성할 수 있다.

  * 버퍼의 사용

    CPU의 연산속도가 입출력 장치보다 훨씬 빠르기 때문에 입출력장치를 CPU가 기다리는 것은 비효율적이다. 그래서 입력시 버퍼에 데이터를 쌓아놓고 CPU가 연산을 하고, 또 결과도 버퍼에 저장해놓았다가 한번에 출력한다.

<br>

### 표준 입출력 스트림

몇 개의 기본적인 스트림들은 프로그래머가 생성하지 않아도 자동으로 생성된다.

|  이름  |      스트림      |   연결장치    |
| :----: | :--------------: | :-----------: |
| stdin  | 표준 입력 스트림 |    키보드     |
| stdout | 표준 출력 스트림 | 모니터의 화면 |
| stderr | 표준 오류 스트림 | 모니터의 화면 |

<br>

### 입출력 함수의 분류

입출력 함수들은 사용하는 스트림과 입출력 형식이 지정되느냐 않느냐에 따라 분류할 수 있다.

| 형식 / 스트림                         | 표준 스트림 | 일반 스트림           | 설명               |
| ------------------------------------- | ----------- | --------------------- | ------------------ |
| 형식이 없는 입출력 ( 문자 형태 )      | getchar()   | fgetc(FILE *f, ...)   | 문자 입력 함수     |
|                                       | putchar()   | fputc(FILE *f, ...)   | 문자 출력 함수     |
|                                       | gets()      | fgets(FILE *f, ...)   | 문자열 입력 함수   |
|                                       | puts()      | fputs(FILE *f, ...)   | 문자열 출력 함수   |
| 형식이 있는 입출력 ( 정수, 실수 ... ) | printf()    | fprintf(FILE *f, ...) | 형식화된 출력 함수 |
|                                       | scanf()     | fscanf(FILE *f, ...)  | 형식화된 입력 함수 |

* 형식이 있는 입출력은 정수나 실수 등 데이터의 형식을 지정하는 입출력을 의미한다.

<br><br>

## 16.2 printf() 출력

```c
int printf(char *format, ...); // 형식

printf("%10d %20.3f\n", index, value); // 예제, 표준 출력 스트림(콘솔)에 데이터를 출력한다.
```

<br>

### 형식 제어 문자열

printf()에 첫 번째 매개변수인 format은 형식 제어 문자열이라고 불린다. 형식 제어 문자열은 변수나 수식의 값을 출력하는 형식을 지정한다.

형식 제어 문자열에서 필수적으로 있어야 하는 것은 **'형식'**뿐이다.  다른 것들은 선택 사항이다.

```c
%[플래그][필드폭][.정밀도] <형식>
```

#### 플래그(flag)

플래그는 하나의 문자로서 출력의 정렬과 부호 출력, 공백 출력, 8진수와 16진수 접두사 출력 등을 지시한다.

| 기호       | 의미                                                         | 기본값                       |
| ---------- | ------------------------------------------------------------ | ---------------------------- |
| -          | 출력 필드에서 출력값을 왼쪽 정렬한다.                        | 오른쪽 정렬된다.             |
| +          | 결과 값을 출력할 때 항상 +와 -의 부호를 붙인다.              | 음수일 때만 - 부호를 붙인다. |
| 0          | 출력값 앞에 공백문자 대신 0으로 채운다.                      | 채우지 않는다.               |
| blank(' ') | 출력값 앞에 양수나 영인 경우 부호 대신 공백을 출력한다.      | 공백을 출력하지 않는다.      |
| #          | 8진수 출력 시에는 출력값 앞에 0을 붙이고 16진수 출력시에는 0x를 붙인다. | 붙이지 않는다.               |

#### 필드폭(width)과 정밀도(precision)

데이터가 출력되는 필드의 크기를 지정할 수 있다. 출력 값이 필드 폭보다 더 적은 개수의 문자로 출력된다면 스페이스가 덧붙여지고 더 많은 문자를 필요로 한다면 필드가 확장된다.

필드폭은 %와 형식 지정자 사이에 들어간다.

정밀도는 필드폭과 형식 지정자 사이에 .과 함께 들어간다.

```c
printf("%10.3d", 123.123456); // 예제. 폭은 10, 소숫점 이하 3자리까지 출력.
// 결과:   123.123
```

#### 형식

| 형식 지정자 | 설명                                          | 출력 예    |
| ----------- | --------------------------------------------- | ---------- |
| %d          | 부호 있는 10진수 형식으로 출력                | 255        |
| %i          | 부호 있는 10진수 형식으로 출력                | 255        |
| %u          | 부호 없는 10진수 형식으로 출력                | 255        |
| %o          | 부호 없는 8진수 형식으로 출력                 | 377        |
| %x          | 부호 없는 16진수 형식으로 출력, 소문자로 표기 | fe         |
| %X          | 부호 없는 16진수 형식으로 출력, 대문자로 표기 | FE         |
| %f          | 소숫점 고정 표기 형식으로 출력                | 123.456    |
| %e          | 지수 표기 형식으로 출력 지수 부분을 e로 표시  | 1.23456e+2 |
| %E          | 지수 표기 형식으로 출력 지수 부분을 E로 표시  | 1.23456E+2 |
| %g          | %e 형식과 %f 형식 중 더 짧은 형식으로 출력    | 123.456    |
| %G          | %E 형식과 %f 형식 중 더 짧은 형식으로 출력    | 123.456    |
| %p          | 포인터 형식으로 출력                          | 0027FDDO   |

실수를 표기하는 방법에는 두가지 방법이 있다.

* 정수부와 소수부를 나눠서 표기

  %f가 여기에 해당되고 정수부와 실수부를 나눠서 표기한다.

* 과학적 표기법으로 표기

  %e, %E가 여기에 해당되고 실수를 가수와 지수로 분리하여 표기한다.

<br><br>

## 16.3 scanf()를 이용한 입력

scanf()는 표준 입력에서 어떤 형식(format)을 지정하여 데이터를 받아들이는 함수이다. getchar()나 gets()와는 다르게 문자열을 숫자의 형태로 자동적으로 변환시켜 주므로 편리하다.

scanf()는 문자열을 정수, 실수로 변환하는 역할을 한다.

```c
int scanf(char *format, ...); // 형식

scanf("%d", &value); // 예제. 표준 입력 스트림(키보드)에서 데이터를 입력한다. 읽은 항목의 수를 반환한다.
```

형식 제어 문자열 format은 <u>사용자로부터 받은 문자열을 변환하는 형식을 지정한다.</u> 형식 제어 문자열에는 플래그, 필드 넓이, 형식 지정자 등을 가질 수 있다.

scanf()는 사용자가 입력하는 문자열을 공백문자(줄바꿈, 탭, 스페이스)로 분리하여 각각의 형식 지정자에 연결시킨다.

<br>

### 필드폭 지정하여 읽기

형식 제어 문자열에 필드폭이 지정되었으면 필드폭 만큼의 문자를 읽어서 값으로 변환한다.

```c
scanf("%3d%3d", &a, &b); // 123456을 입력하면 a, b에 각각 123, 456이 저장된다.
```

<br>

### 8진수, 16진수 입력

형식 제어 문자열에 형식 지정자가 다르면 서로 다른 값이 변수에 저장된다.

```c
scanf("%d %o %x", &a, &b, &c); // 각 문자열에 10을 대입해도 %d는 10, %o는 8 %x는 16의 변수를 저장한다.
printf("d=%d o=%d x=%d", a, b, c);
```

<br>

### 문자와 문자열 읽기

| 분류   | 형식 지정자 | 설명                                                         |
| ------ | ----------- | ------------------------------------------------------------ |
| 문자형 | %c          | char형으로 입력받는다.                                       |
|        | %s          | 공백 문자가 아닌 문자부터 공백 문자가 나올 때까지를 문자열로 변환하여 입력받는다. |
|        | %[abc]      | 대괄호 안에 있는 문자 a, b, c로만 이루어진 문자열을 읽어 들인다. |
|        | %\[^abc]    | 대괄호 안에 있는 문자 a, b, c만을 제외하고 다른 문제들로 이루어진 문자열을 읽어들인다. |
|        | %[0-9]      | 0에서 9까지의 범위에 있는 문자들로 이루어진 문자열을 읽어 들인다. |

scanf()로 문자를 읽을때는 형식 지정자 %c를 이용해서 읽는다. 문자를 읽는 경우 형식지정자가 붙어 있는지, 떨어져 있는지에 따라 결과가 달라진다.

* 형식 지정자 사이에 공백 문자가 있는 경우

  공백 문자를 이용하여 문자들을 분리한다.

* 형식 지정자들이 붙어 있는 경우

  공백 문자도 하나의 문자로 취급되어 입력된다.

문자열은 %s로 읽어서 char형 배열에 저장한다.

<br>

### 문자 집합으로 읽기

scanf()에는 **문자 집합을 기호로 표시하고 이 문자 집합에 포함된 문자만을 읽을 수 있는 기능이 들어 있다.**

읽고 싶은 문자 집합은 문자들을 대괄호[ ]로 묶어서 표시한다.

```c
scanf("%[abc]", s); // a,b,c로 이루어진 문자열만 받음.
```

<br>

###  scanf()의 반환값 이용

scanf()가 반환하는 값을 읽은 항목의 개수이다. 따라서 이것을 이용하면 사용자가 값을 몇 개나 성공적으로 입력하는였는지 검사할 수 있다.

```c
if (scanf("%d%d%d", &x, &y, &z) == 3)
    printf("정수들의 합은 %d\n", x+y+z);
else
    printf("입력값이 올바르지 않습니다.");
```

<br>

### fflush()의 사용

만약 scanf()를 사용하여서 입력을 처리할 때 이전에 입력되었던 값들이 버퍼에 남아 있어서 방해가 된다면 fflush(stdin) 함수를 호출하면 된다.

```c
scanf("%c", &ch);
fflush(stdin);
printf("%d ", ch);
```

<br><br>

## 16.4 파일의 기초

여태까지 대부분의 예제 프로그램은 표준 입력인 키보드와 표준 출력인 모니터를 사용하였다. 하지만 **실제 응용 프로그램에서는 데이터나 현재의 설정 정보를 저장하기 위하여 디스크에 저장되는 파일을 많이 사용한다.**

파일을 사용하면 데이터를 영구적으로 보관할 수 있다. C에서는 디스크에 파일을 생성시켜서 데이터를 보관할 수 있다.

<br>

### 파일의 개념

C에서의 모든 입출력은 스트림을 통하여 이루어진다. 파일도 마찬가지로 스트림으로 취급되어 일련의 연속된 바이트로 생각할 수 있기 때문에 파일에 대한 입출력도 표준 입출력과 동일한 함수들로 이루어진다.

파일 입출력을 위해서는 프로그래머가 파일 이름을 직접 결정하여 파일 스트림을 생성하여야 한다.

모든 파일은 입출력 동작이 발생하는 현재 위치를 나타내는 **파일 포인터(file pointer)를 가지고 있다.** 파일을 처음으로 열면 파일 포인터는 첫 번째 바이트를 가리킨다. 입출력 연산이 진행되면 파일 포인터가 자동적으로 이동된다.

<br>

### 파일의 유형

C에서는 텍스트 파일(text file)과 이진 파일(binary file)의 두 가지 파일 유형을 지원한다.

* 텍스트파일

  사람이 읽을 수 있는 텍스트가 들어 있는 파일이다. 메모장이나 소스 파일이 텍스트 파일의 예이다.

  * 문자들이 들어있고 아스키 코드를 이용하여 표현된다.
  * **텍스트 파일은 모니터, 키보드, 프린터등이 모두 문자 데이터만을 처리하기 때문에 중요하다.**
  * 텍스트 파일은 연속적인 줄(line)들로 구성된다.
    * 텍스트 파일에서는 문자열의 끝을 나타내는데 NULL문자를 사용하지 않는다. 대신 줄의 끝을 표시하기 위해여 \n을 사용한다.
    * 윈도우는 캐리지 리턴(\r)과 줄바꿈 문자(CR-LF)의 조합으로 이루어진다.

* 이진 파일

  사람이 읽을 수 없으나 컴퓨터는 읽을 수 있는 파일이다. 문자 데이터가 아니라 이진 데이터가 직접 저장되어 있는 파일이다. 실행 파일, 사운드 파일, 이미지 파일 등이 이진 파일의 예이다.

  * 이진 파일은 텍스트 파일과 달리, 줄들로 분리되지 않는다. 모든 데이터들은 문자열 형태가 아진, 이진수 형태로 저장된다.
  * **이진 파일은 특정 프로그램에 의해서만 판독이 가능하다.**
  * 텍스트 파일처럼 한 줄이라는 개념이 없기 때문에 줄의 끝을 표시할 필요가 없으며 <u>NULL이나 CR, LF와 같은 문자들도 특별한 의미를 가지지 않고 단순히 데이터로 취급</u>된다.

<br>

### 파일 처리의 개요

프로그램에서 **파일을 연다(open)**는 것은 파일에서 데이터를 읽거나 쓸 수 있도록 모든 준비를 마치는 것을 의미한다. **내부적으로는 파일과 연결된 스트림을 만들게 된다.** 파일을 열면 데이터를 읽고, 쓸 수 있다.

파일을 사용한 후에는 파일을 닫아야(close)한다.

* '파일 열기 - 파일 읽기와 쓰기 - 파일 닫기' 순서를 지켜야한다.

<br>

### 파일 열기

파일을 열려면 라이브러리 함수를 사용해야 한다.

```c
FILE *fopen (const char *name, const char *mode); // 형식 매개변수는 각각 파일의 이름, 파일의 모드를 가리킴
// name이라는 이름을 가지는 파일을 mode에 지정된 모드로 연다. FILE 포인터를 변환한다.

FILE *fp;
fp = fopen("test.txt", "w"); // 예제. test.txt라는 이름을 가지는 파일을 쓰기모드로 연다.
```

* 기본적인 파일모드

  * "r" : 읽기모드

    읽기 작업을 위해 파일을 여는 것이다.

  * "w" : 쓰기모드

    데이터를 쓰기 위해 파일을 여는 것이다.

  * "a" : 추가모드

    파일이 없으면 새로운 파일을 만들고, 파일이 있으면 끝에 추가한다.

* 파일모드 표 정리

  | 모드 | 설명                                                         |
  | ---- | ------------------------------------------------------------ |
  | "r"  | 읽기 모드로 파일을 연다. 만약 파일이 존재하지 않으면 오류가 발생한다. |
  | "w"  | 쓰기 모드로 새로운 파일을 생성한다. 파일이 이미 존재하면 기존의 내용이 지워진다. |
  | "a"  | 추가 모드로 파일을 연다 만약 기존의 파일이 있으면 데이터가 파일의 끝에 추가된다. 파일이 없으면 새로운 파일을 만든다. **파일이 절대 지워지지 않는다.** |
  | "r+" | 읽기 모드로 파일을 연다. 쓰기 모드로 전환할 수 있다. 파일이 반드시 존재해야 한다. |
  | "w+" | 쓰기 모드로 새로운 파일을 생성한다. 읽기 모드로 전환할 수 있다. 파일이 이미 존재하면 기존의 내용이 지워진다. |
  | "a+" | 추가 모드로 파일을 연다. 읽기 모드로 전환할 수 있다. 데이터를 추가하면 EOF 마커를 추가된 데이터의 뒤로 이동한다. 파일이 없으면 새로운 파일을 만든다. **파일이 절대 지워지지 않는다.** |
  | "t"  | 텍스트 파일 모드로 파일을 연다.                              |
  | "b"  | 이진 파일 모드로 파일을 연다.                                |

  * 기본적인 파일 모드에  "t", "b"를 붙여서 "rb"형식으로 쓸수도 있고, 붙이지 않은 경우 텍스트파일로 간주한다.
  * 모드를 전환할 수 있을 때 전환하려면 fflush(), fsetpos(), fseek(), rewind() 중 하나의 함수를 사용하여야 한다.

<br>

### 파일 닫기

열린 파일을 닫는 함수는 fclose이다. fclose()는 stdio.h에 정의되어 있다.

```c
int fclose(FILE *stream); // 형식. stream에 의하여 지정된 파일을 닫는다.

FILE *fp; // 예제
fp = fopen("test.txt", "w");
fclose(fp);
```

* 성공적으로 파일을 닫는 경우 0이 반환된다. 실패한 경우 -1이 반환된다.

<br>

### 파일 삭제

파일을 삭제하는 함수는 remove()이다. remove()는 stdio.h에 정의되어 있다.

```c
remove("sample.txt"); // 예제. 파일 sample.txt를 삭제한다.
```

* 성공적으로 파일을 삭제하는 경우 0이 반환되고 실패하는 경우 -1이 반환된다.

<br>

### 기타 유용한 함수들

| 함수                                                 | 설명                                                         |
| ---------------------------------------------------- | ------------------------------------------------------------ |
| int foef(FILE *stream)                               | 파일에 끝에 도달되면 true를 반환한다.                        |
| int rename(const char *oldname, const char *newname) | 파일의 이름을 변경한다.                                      |
| FILE *tmpfile()                                      | 임시 파일을 생성하여 반환한다.                               |
| int ferror(FILE *stream)                             | 스트림의 오류 상태를 반환한다. 오류가 발생하면 true가 반환된다. |

<br><br>

## 16.5 텍스트 파일 읽기와 쓰기

파일을 열었으면 프로그램에서는 파일에서 데이터를 읽을 수도 있고 쓸 수도 있다.

* 파일 입출력에 관계되는 라이브러리 함수

| 종류            | 입력 함수                                                 | 출력 함수                                                  |
| --------------- | --------------------------------------------------------- | ---------------------------------------------------------- |
| 문자 단위       | int fgetc(FILE *fp)                                       | int fputc(int c, FILE *fp)                                 |
| 문자열 단위     | char *fgets(char *buf, int n, FILE *fp)                   | int fputs(const char *buf, FILE *fp)                       |
| 서식화된 입출력 | int fscanf(FILE *fp)                                      | int fprintf(FILE *fp, ...)                                 |
| 이진 데이터     | size_t fread(char *buffer, int size, int count, FILE *fp) | size_t fwrite(char *buffer, int size, int count, FILE *fp) |

*  문자, 문자열 단위의 입출력

  문자, 문자열 단위의 입출력은 파일에 사람들이 읽을 수 있는 텍스트 형태로 데이터를 저장하는 것이고 **텍스트 파일에서만 가능하다.**

  * 함수의 반환값은 성공적으로 읽은 항목의 수를 반환하므로 반환값이 0이면 입출력이 실패했음을 의미한다.
  * 입출력이 실패하는 이유는 오류가 발생했을수도 있고, 파일이 끝났을수도 있다.
    * 오류가 발생하는 경우  feof()나 ferror()를 호출하면 된다.

* 서식화된 입출력

  서식화된 입출력은 입출력 형식을 지정하여 파일에 그 형식으로 데이터를 저장할 수 있다. **텍스트 파일에서만 가능하다.**

  * 텍스트와 숫자가 포함된 데이터를 정해진 형식으로 파일에 기록하는데 사용한다.

* 이진 데이터 입출력

  이진 데이터 입출력은 메모리에 있는 데이터를 직접 디스크 파일에 그대로 저장하는 것이다.**이진 파일에서만 가능하다.**

  * 전용 프로그램에서 나중에 사용하기 위한 데이터를 저장하기 위해서 사용한다.

<br>

### 문자 단위 입출력

fputc()를 이용해서 텍스트 파일을 생성할 수 있다.

* fputc.c Code

  ```c
  #include <stdio.h>
  
  int main(void)
  {
      FILE *fp = NULL;
      fp = fopen("sample.txt", "w");
      if( fp == NULL )
          printf("file open fail\n");
      else
          printf("file open success\n");
      fputc('a', fp);
      fputc('b', fp);
      fputc('c', fp);
      fclose(fp);
      return 0;
  }
  ```

  * sample.txt 파일에 abc가 저장되어 있다.

fgetc()를 이용해서 텍스트 파일의 내용을 화면에  표시할 수 있다.

* fgetc.c Code

  ```c
  #include <stdio.h>
  
  int main(void)
  {
      FILE *fp = NULL;
      int c;
  
      fp = fopen("sample.txt", "r");
      if( fp == NULL )
          printf("file open fail.\n");
      else
          printf("file open success.\n");
      while((c = fgetc(fp)) != EOF)
          putchar(c);
      fclose(fp);
      return 0;
  }
  ```

  * 실행 결과 파일을 열고 abc를 출력한다.

<br>

### 문자열 단위 입출력

문자들로 이루어진 하나의 라인을 입력받으러면 fgets()를 사용하여야 한다.

```c
char *fgets(char *s, int n, FILE *fp); // 입력 형식
// fp에서 문자들을 읽어서 s가 가리키는 위치에 저장한다. 하나의 줄이 완전히 읽히거나 n-1개의 문자들이 읽히면 종료된다. s는 입력 문자열이 저장되는 버퍼이고 n은 입력 가능한 최대 문자 개수이다.
int fputs(char *s, FILE *fp); // 출력 형식
// s가 가리키는 문자열을 fp에 저장한다.
```

텍스트 파일을 복사하는 코드를 작성할 수 있다.

* fcopy1.c

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  
  int main(void)
  {
      FILE *fp1, *fp2;
      char file1[100], file2[100];
      char buffer[100];
  
      printf("file name: ");
      scanf("%s", file1);
  
      printf("copy file name: ");
      scanf("%s", file2);
  
      if( (fp1 = fopen(file1, "r")) == NULL )
      {
          fprintf(stderr, "we can not open file '%s'.\n", file1);
          exit(1);
      }
  
      if( (fp2 = fopen(file1, "w")) == NULL )
      {
          fprintf(stderr, "we can not open copy file '%s'.\n", file2);
          exit(1);
      }
  
      while(fgets(buffer, 100, fp1) != NULL)
          fputs(buffer, fp2);
  
      fclose(fp1);
      fclose(fp2);
  
      return 0;
  }
  ```

<br>

### 형식화된 입출력

파일에 문자 데이터를 기록하는 경우에는 앞에  fputc()나 fputs()를 사용하면 되지만 **정수나 실수 데이터를 기록하는 형식화된 입출력의 경우 fprintf()와 fscanf()를 이용하여 이루어진다.**

```c
int fprintf( FILE *fp, const char *format, ...); // 출력형식
// 형식화된 출력. 출력 대상은 모니터가 아니라 파일이다.
int fscanf(FILE *fp, const char *format, ...); // 입력형식
// 형식화된 입력. 입력 대상은 모니터가 아니라 파일이다.
```

사용자가 입력하는 학생들의 성적을 텍스트 파일에 저장하였다가 다시 읽어 평균을 계산해 화면에 출력하는 프로그램을 작성

* average.c Code

  ```C
  #include <stdio.h>
  #include <stdlib.h>
  
  int main(void) {
      FILE *fp;
      char fname[100];
      int number, count = 0;
      char name[20];
      float score, total = 0.0;
  
      printf("input file name of grade : ");
      scanf("%s", fname);
  
      if ((fp = fopen(fname, "w")) == NULL) {
          fprintf(stderr, "we can not open file of grade '%s'.\n", fname);
          exit(1);
      }
  
      // 사용자로부터 학번, 이름, 성적을 받아서 파일에 저장한다.
      while (1) {
          printf("input student number, name, grade : (exit = -1) ");
          scanf("%d", &number);
          if (number < 0) break;
          scanf("%s %f", name, &score);
          fprintf(fp, "%d %s %f\n", number, name, score);
      }
      fclose(fp);
  
      // 성적파일을 읽기 모드로 연다.
      if( (fp = fopen(fname, "r")) == NULL )
      {
          fprintf(stderr, "we can not open file of grade '%s'.\n", fname);
          exit(1);
      }
  
      // 파일에서 성적을 읽어서 평균을 구한다.
      while( !feof(fp) )
      {
          fscanf(fp, "%d %s %f", &number, name, &score);
          total += score;
          count++;
      }
  
      printf("average : %f\n", total/count);
      fclose(fp);
  
      return 0;
  }
  ```

<br><br>

## 16.6 이진 파일 읽기와 쓰기

<br>

### 이진 파일의 개념

텍스트 파일에서는 모든 정보가 문자열로 변환되어 파일에 기록되었지만, 이진 파일의 경우 이진수 형태로 그대로 파일에 기록된다.

* 이진 파일의 장점

  텍스트 파일은 함수를 써서 변환하는 과정이 시간이 많이 걸리고 비효율적이지만 이진 파일은 변환 과정이 없이 **효율적으로 바로 읽을 수 있고 공간도 적게 차지한다.**

* 이진 파일의 단점

  인간이 파일의 내요을 확인하기가 힘들고 아스키 코드 형태로 되어있지 않기 때문에 모니터나 프린터로 출력하는 것도 불가능하다. 그리고 다른 컴퓨터에서 표현 방식이 다를 경우 실행되지 않으므로 이식성이 텍스트 파일보다 떨어진다.

따라서 <u>이식성이 중요한 경우 비효율적이더라도 텍스트 파일 형식을 사용하고, 데이터가 상당히 크도 실행속도가 중요하다면 이진 파일로 하는 것이 좋다.</u>

<br>

### 이진 파일 쓰기

fwrite()함수를 통해 이진 파일을 쓸 수 있다.

```c
fwrite(buffer, sizeof(int), SIZE, fp); // 형식
// 매개변수 순서대로 메모리블록의 주소, 항목의 크기, 항목의 개수를 나타낸다.
// 메모리에서 데이터 블록을 파일에 쓰는 함수이다. buffer는 파일에 기록할 데이터를 가지고 있는 메모리 블록의 시작 주소이다.
```

배열에 저장된 정수값을 이진 파일에 저장하여 보자.

* binary1.c Code

  ```c
  #include <stdio.h>
  
  #define SIZE 5
  int main(void)
  {
      int buffer[SIZE] = { 10, 20, 30, 40, 50 };
      FILE *fp = NULL;
  
      fp = fopen("binary.bin", "wb");
      if( fp == NULL)
      {
          fprintf(stderr, "binary.bin file can not open.");
          return 1;
      }
  
      fwrite(buffer, sizeof(int), SIZE, fp);
  
      fclose(fp);
      return 0;
  }
  ```

  * binary.bin 파일이 만들어지고 정수값이 저장된다.

<br>

### 이진 파일 읽기

fread() 함수를 통해 이진 파일로부터 값을 읽어온다.

```c
fread(buffer, sizeof(int), SIZE, fp); // 형식
// 매개변수 순서대로 메모리블록의 주소, 항목의 크기, 항목의 개수를 나타낸다.
// 이진 파일에서 값을 읽는 함수이다. buffer는 파일로부터 읽어오는 데이터를 저장할 메모리 블록의 시작 주소이다.
```

binary.bin 파일의 데이터를 화면에 표시하는 프로그램을 작성한다.

* binary2.c Code

  ```c
  #include <stdio.h>
  #define SIZE 5
  
  int main(void)
  {
      int i;
      int buffer[SIZE];
      FILE *fp = NULL;
  
      fp = fopen("binary.bin", "rb");
      if( fp == NULL)
      {
          fprintf(stderr, "binary.bin file can not open.");
          return 1;
      }
      fread(buffer, sizeof(int), SIZE, fp);
  
      for(i=0 ; i<SIZE ; i++)
          printf("%d ", buffer[i]);
  
      fclose(fp);
      return 0;
  }
  ```

<br>

### 버퍼링

스트림에는 기본적으로 버퍼(buffer)가 포함되어 있다.

**버퍼는 파일로부터 읽고 쓰는 데이터의 임시 저장 장소로 이용되는 메모리의 블록이다.**

* 버퍼가 있으면 출력 데이터는 일단 버퍼에 쓰여진다. 버퍼가 다 채워지면 디스크 파일에 버퍼의 내용을 기록한다.

* 버퍼를 두는 이유는 디스크에서 물리적으로 데이터를 읽을 때는 상당한 시간이 걸리기 때문이다. 따라서 한번 읽을 때 많이 읽어두고 나중에 다음 데이터가 필요하면 바로 버퍼에서 갖다 주는 것이다.

 프로그램에 따라 버퍼를 비워야 하는 경우가 발생할 수 있다.

* fflush

  프로그램이 쓴 데이터가 즉시 하드웨어 장치에 써지기를 원한다면 버퍼를 비워야한다.

  * 버퍼는 fflush()를 호출하면 비워지고 버퍼의 내용이 디스크파일에 써진다.

    ```c
    fflush(fp);
    ```

    * 파일이 읽기모드로 열려 있는 경우 버퍼의 내용이 지워진다.
    * 파일이 쓰기모드로 열려 있는 경우 버퍼의 내용이 기록된다.

프로그램에 따라 버퍼가 있으면 안되는 경우가 발생할 수 있다.

* setbuf

  많은 양의 이진 데이터를 쓰거나 읽을 경우 버퍼가 없는 편이 편하다.

  * setbuf()는 스트림의 버퍼를 직접 지정하는 함수로, 만약 버퍼 자리에 NULL을 쓰면 버퍼를 제거하겠다는 것을 의미한다.

    ```c
    setbuf(fp, NULL);
    ```

    * 버퍼가 없는 입출력의 경우 시스템 호출이 많이 필요하므로 곡 필요한 경우에만 setbuf 함수를 사용하여야 한다.

<br><br>

## 16.7 임의 접근

<br>

### 순차 접근

데이터를 파일의 처음부터 순차적으로 읽거나 기록하는 것을 순차 접근이라고 한다.

순차접근의 경우 데이터를 다시 읽으려면 현재의 파일을 닫고 파일을 다시 열어야 한다. 또, 중간 중간 건너뛸수도 없다.

<br>

### 임의 접근

임의 접근은 파일에 어느 위치에서든지 읽고 쓰기가 가능하다.

#### 임의접근의 원리

모든 파일에는 파일 포인터(file pointer)라는 것이 존재한다. 파일 포인터는 읽기와 쓰기 동작이 현재 어떤 위치에서 이루어지는 지를 나타낸다.

* 새 파일이 만들어지면 파일포인터의 값은 0이고 이것은 파일 시작 부분을 가리킨다.
* 읽기나 쓰기가 수행되면 파일 포인터가 갱신된다.

**임의 접근은 임의로 파일포인터를 이동시켜 임의 파일 액세스하는 것을 가리킨다.**

* 파일의 임의의 위치에서 읽고 쓰고 싶은 경우 위치 표시자를 조작하여 파일 포인터를 원하는 임의의 위치로 이동할 수 있다.
  * 위치 표시자를 조작하는 함수는 fseek()이다.

<br>

### 파일 포인터 관련 함수

#### fseek()

**fseek() 함수**를 이용하면 위치 표시자를 보다 정밀하게 제어할 수 있다.

```c
int fseek(FILE *fp, long offset, int origin); // 형식
// fp는 FILE에 대한 포인터이다. offset은 기준 위치로부터 위치 표시자가 이동하는 거리를 나타낸다.origin은 위치 표시자를 이동시키는 기준 위치를 나타낸다.
```

* 성공하면 0을 반환하고 실패하면 0이 아닌 값을 반환한다.

* offset은 long형이므로 정수 상수를 인수로 사용하는 경우 3000L과 같이 L을 붙이는게 좋다.

* origin은 위치 표시자를 이동시키는 기준 위치를 나타내고 기준이 되는 값이 있다.

  | 상수     | 값   | 설명        |
  | -------- | ---- | ----------- |
  | SEEK_SET | 0    | 파일의 시작 |
  | SEEK_CUR | 1    | 현재 위치   |
  | SEEK_END | 2    | 파일의 끝   |

#### rewind()

파일 포인터를 파일의 시작위치로 설정하는 방법은 fseek()함수 말고도 **rewind() 함수**도 있다.

```c
void rewind(FILE *fp); // 형식
// 호출되면 위치 표시자가 0으로 설정된다.
```

* 주로 파일을 읽은 다음, 다시 읽고자 할 때 사용된다.

#### ftell()

위치 표시자의 현재 위치를 알아내려면 **ftell() 함수**를 사용한다.

```c
long ftell(FILE *fp); // 형식
// 현재 위치 표시자의 값을 long형으로 반환한다.
```

* 파일이 너무 클 경우 long형으로만 표시될 수 있기 때문에 long형으로 반환한다.
* 만약 오류가 발생하면 -1L을 반환한다.

#### feof()

파일의 끝을 알아내는 함수는 **feof() 함수**이다.

```c
int feof(FILE *fp); // 형식
// 현재 위치가 파일의 끝인지 알려준다.
```

* 이진 파일의 경우 -1이 얼마든지 데이터일 수 있기 때문에 이 함수가 필요하다.