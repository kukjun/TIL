# Chapter14 포인터 활용

### 학습목표

* 포인터의 포인터, 포인터 배열, 함수 포인터들을 학습한다.
* 다차원 배열과 포인터의 관계를 살펴본다.
* main() 함수의 인수에 대하여 살펴본다.

<br>

## 14.1 이중 포인터 // 다시보기

포인터도 변수이기 때문에 주소값을 가지고 있다. **따라서 포인터의 포인터도 존재할 수 있다.**<SPAN STYLE="COLOR:RED">아<SPAN>

* 정수형 포인터를 가리키는 이중 포인터

  ```c
  int **q; // int형에 포인터에 대한 이중 포인터 선언
  /*
  int - 정수형을
  * - 가리키는 포인터를
  * - 가리키는 포인터
  */
  ```

  * 이중 포인터 선언과 연결

    ```c
    int i = 100; // i는 int형 변수
    int *p = &i; // p는 i를 가리키는 포인터
    int **q = &p; // q는 포인터 p를 가리키는 이중 포인터
    /*
    p는 변수 i의 주소를 가지고 있음.
    *p는 변수 i의 값을 가리킴
    q는 포인터 p의 주소를 가지고 있음.
    *q는 포인터 p의 값을 가리킴 - 변수 i의 주소를 가리킴
    **q는 포인터 p의 값의 포인터를 가리킴 - 변수 i의 값을 가리킴
    **q는 *(*q)로 생각할 수 있다. 그러면 *(*q) 가 *p 가되고 *p가 다시 i를 가리킨다.
    ```

    * 포인터와 이중포인터를 통한 변수 변경

      ```c
      *p = 200; // 변수 i의 값이 200으로 변경된다.
      **q = 300; // 변수 i의 값이 300으로 변경된다.
      ```

* 이중 포인터가 가장 많이 사용되는 상황은 외부에서 정의된 포인터 값을  함수의 인수로 받아서 변경하려고 하는 경우다.

<br>

## 14.2 포인터 배열

**포인터 배열**은 포인터들을 모아서 배열로 만든 것이다. 즉, 배열의 원소가 **포인터**이다.

**포인터가 모여 배열이 되는 것이다.**

* 정수형 포인터를 원소로 가지는 배열

  ```c
  int *ap[10]; // 원소가 정수형 포인터인 배열 ap
  // 연산자의 우선순위에 의해 * (ap[10])으로 일단 배열이 되고 int형 포인터가 된다.
  
  int a = 10, b = 20, c = 30, d = 40, e = 50;
  int *api[5] = { &a, &b, &c, &d, &e }; // 포인터가 각각 abcde를 가리킨다.
  ```


### 1. 문자형 포인터 배열

포인터 배열중에 가장 많이 사용되는 형태는 문자형 포인터 배열이다.

#### 래그드 배열(ragged array)

문자형 포인터 배열 중 행의 길이가 불규칙 적일 때, 효율적인 메모리 사용을 위해 사용하는 배열을 래그드 배열이라고 한다.

2차원 배열로 구현된 문자열 배열보다, 래그드 배열이 더 메모리를 아낄 수 있다.

* **래그드 배열은 이중포인터로 사용할 수 있다.**

* 2차원 문자형 배열

  ```c
  char fname[4][10] = {
      "apple",
      "blueberry",
      "orange",
      "melon"
  };
  // 쓰이지 않는 열이 있어 행의 공간의 낭비가 존재한다.
  ```

* 래그드 배열

  ```c
  char fruits[4] = {
      "apple",
      "blueberry",
      "orange",
      "melon"
  };
  // 저장공간의 낭비가 없어서 효율적이다.
  ```

  * 포인터의 배열이므로 배열의 저장공간은 **포인터의 크기 * 원소의 개수**이다.
    * 문자열 상수는 text segment 영역에 저장되어 있다.

<br>

## 14.3 배열 포인터

**배열포인터(a pointer to an array)**는  배열을 가리키는 포인터이다.

**즉, 배열타입 하나를 가리키는 포인터이다.**

```c
int (* pa)[10]; // 괄호가 있으므로 먼저 포인터가 된다.
```

<br>

## 14.4 함수 포인터

함수를 가리키는 포인터를 **함수 포인터(function pointer)**라고 한다. 함수 포인터는 함수가 시작되는 주소를 가리킨다.

* **함수도 실행되는 주소를 가지고 있기 때문에 이 주소를 포인터에 넣을 수 있고 함수를 호출 할 수 있다.**

* 함수포인터 선언

  ```c
  반환형 (*함수포인터이름)(매개변수 1, 매개변수 2, ...); // 형식
  // 함수를 가리키는 포인터를 선언한다. 반드시 괄호가 필요하다. 왜냐하면 괄호에 의하여 pf가 먼저 포인터가 되어야 하기 때문이다.
  int (*pf)(int, int);
  //pf는 int f(int, int)를 가리키는 포인터가 된다.
  ```

  * 선언된 함수 포인터는 매개변수, 반환형이 정확하게 일치하는 함수만을 가리킬 수 있다.

    ```c
    int sub(int, int); // 함수 선언
    int (*pf)(int, int); // 함수 포인터 선언
    ...
    pf = sub; // 함수의 이름을 함수 포인터에 대입
    ```

    * pf에 시작주소를 대입하는 것으로 이후부터 pf가 sub()를 가리키게 된다.
      * **함수도 이름이 시작주소를 의미하는 포인터 상수**
    * 반환형과 매개변수가 일치하면 함수를 바꿔가며 사용할 수 있다.

  * 함수 포인터를 이용하여 함수를 호출할 수 있다.

    ```c
    result = (*pf)(10, 20); // sub(10, 20)과 같다.
    // 괄호없이 *pf(10, 20)을 하면 *(pf(10, 20))이 된다. pf(10, 20)이 실행되고, 함수의 반환값이 가리키는 내용이 된다.
    ```

  * 함수 포인터 대신 함수 이름처럼 사용할 수도 있다.

    ```c
    result = pf(10, 20);
    ```

### 1. 함수 포인터의 배열

함수 포인터도 함수의 주소가 들어 있는 변수이기 때문에 배열로 만들 수 있지만 표기법이 상당히 복잡해진다.

하지만 **함수 포인터의 배열은 실제 응용 프로그램에서 비교적 많이 사용된다.**

* 함수 포인터의 배열선언

  ```c
  반환형	(*배열이름[배열의_크기])(매개변수목록); // 형식
  // 함수 포인터의 배열을 선언한다.
  int (*pf[5]) (int, int);
  /* 먼저 pf는 포인터들의 배열이 된다.
  ```

### 2. 함수 인수로서의 함수 포인터

함수 포인터는 함수의 인수로서 사용할 수 있다. 이를 사용하면 **호출된 함수가 특정한 함수를 호출해주도록 호출하는 측에서 결정할 수 있다.**

* ex

  ```c
  double f1(double k); // 함수 포인터 f1 선언
  double f2(double k); // 함수 포인터 f2 선언
  double func(double (*fp)(double), int n); // 함수의 인수가 함수 포인터인 함수 func선언
  ```

  

<br>

## 14.5 다차원 배열과 포인터

다차원 배열의  이름이 무엇을 가리키는 포인터인지, 포인터를 이용하여 다차원 배열을 참조할 때에 어떻게 해야하는지에 대해 살펴본다.

* 예제를 통한 설명

  ```c
  int m[3][3]; 
  ```

  * C에서는 2차원 배열을 저장할 때 행우선 방법으로 행을 기준으로 하여서 상위 행을 먼저 저장하는 방법을 사용한다.
    * m\[0]\[0], m\[0]\[1], m\[0]\[2], m\[1]\[0], m\[1]\[1] ... 순서대로 저장

  * 2차원 배열 이름은 m\[0]\[0]을 가리킨다.
    * m[0]은 0번째 행의 시작주소와 같고, m[1]과 m[2]는 각각의 행의 시작 주소와 같다.

### 1. 다차원 배열의 이해

다차원 배열은 배열의 배열로 생각하면 이해가 쉬워진다.

* m이라는 배열은 m[0], m[1], m[2]의 세 개의 원소로 되어 있는 배열이다.

  * 다시  m[0]은 m\[0]\[0], m\[0]\[1], m\[0]\[2]으로 이루어진 배열이다.

    따라서  m[0], m[1], m[2]도 배열의 이름으로 생각할 수 있다.

* [ ]연산자의 결합법칙에 따라 왼쪽부터 오른쪽으로 연산한다.

### 2. 다차원 배열에서의 포인터 연산

다차원 배열에서 포인터에 대하여 덧셈 연산이나 뺄셈 연산을 할 수 있다.

* 예제를 통한 설명

  ```c
  int m[3][3];
  // m은 m[0], m[1], m[2]으로 이루어져 있으므로, m+1 = m[1]을 가리킨다.
  ```

### 3. 포인터를 이용한 다차원 배열 운행

다차원 배열의 경우 원소를 참조하는 방법을 알아보자.

<u>다차원 배열의 경우에도 행우선 방법으로, 일렬로 메모리가 있기 때문에 이를 이용하면 포인터를 통해 쉽게 참조할 수 있다.</u>

```c
#define ROWS 4
#define COLS 3

int m[ROWS][COLS] = { {10, 20, 30}, {10, 20, 30}, {10, 20, 30}, {10, 20, 30} };
```

* 특정한 행의 원소들의 평균을 구하는 경우

  ```c
  double  get_row_avg(int m[][COLS], int r)
  {
      int *p, *endp;
      double sum = 0.0;
      
      p = &m[r][0];
      endp = &m[r][COLS-1];
      
      while( p <= endp )
          sum += *p++;
      sum /= COLS;
      
      return sum;
  }
  ```

* 전체 원소들의 평균을 구하는 경우

  ```c
  double get_total_avg(int m[][COLS])
  {
      int *p, *endp;
      double sum = 0.0;
      
      p = &m[0][0];
      endp = &m[ROWS-1][COLS-1];
      
      while(p =< endp)
          sum += *p++;
      
      sum /= ROWS * COLS;
      
      return sum;
  }
  ```

<br>

## 14.6 const 포인터와 volatile 포인터

### 1. const 키워드

const는 변하지 않음을 나타내는 키워드이고, 쓰이는 위치에 따라 의미가 달라진다.

```c
const char *p1; // '포인터가 가리키는 곳의 내용'이 변경되지 않음.
char *const p2; // '포인터 자체'가 변경되지 않음.
// *p1 = 'a'; 포인터가 가리키는 곳의 내용을 변경 불가능
p1 = a; // 포인터 자체는 변경 가능
*p2 = 'a'; // 포인터가 가리키는 곳의 내용은 변경 가능
// p2 = a; // 포인터 자체를 변경 불가능
```

### 2. volatile 키워드

변수나 포인터 앞에 volatile 키워드가 있으면 다른 프로세스나 스레드가 값을 항상 변경할 수 있으니 값을 사용할 때마다 다시 메모리에서 읽으라는 것을 의미한다.

* 주로 동일한 메모리를 여러 개의 폴세스나 스레드가 사용할 때 필요하다.
* 어떤 변수가 volatile로 지정되면 컴파일러는 프로그램에 의해 변수에 접근할 때마다 메모리에서 값을 다시 로드한다. 이것은 **컴파일러의 최적화를 방해하지만 불시에 변경되는 값을 처리하는 경우엔 불가피하다.**

<br>

## 14.7 void 포인터

포인터를 선언할 당시 아직 구체적으로 대상물이 정해지지 않은 경우에 사용

* 동적메모리

  17장에서 학습하는 동적 메모리를 할당하는 함수인 malloc()의 경우, 동적 메모리를 받아서 프로그래머가 어떻게 사용할지 모르는 상태에서 동적 메모리를 가리키는 포인터를 넘겨주어야 한다. 이 포인터를 받아, 사용자는 int형으로 사용할 수 있고, double형으로 사용할 수도 있다.
  
  ```c
  void *vp; // 순수하게 메모리의 주소만을 가지고 있는 변수
  ```

* 주소를 입력받을수는 있다.

  ```c
  vp = &a; // 주소는 입력할 수 있지만 이를 사용할 수는 없다.
  ```

* \* 연산자를 혼자 사용할 수 없다.

  ```c
  // *vp; 가리키는 대상이 없기 때문에 사용할 수 없다.
  *(int *)vp; // 명시적인 대상을 가리키는 포인터 타입으로 형변환을 해야한다.
  ```

* 증감 연산자를 사용할 수 없다.

  ```c
  // vp++; 대상물의 크기를 알 수 없기 때문에 사용할 수 없다.
  ```

<br>

## 14.8 main 함수의 인수

main()도 함수이므로 매개 변수와 반환값을 가질 수 있다.

* 매개 변수 선언시 void를 사용해, 매개 변수를 전달받지 못했다.

  ```c
  int main(void) // 외부의 입력을 받지 않는 main
  {
      ...
  }
  ```

* 매개 변수를 전달받는 main도 설정 가능하다.

  ```c
  int main(int argc, char *argv[]) // 외부 입력을 받을 수 있는 main
  {
      ...
  }
  ```

  * argc는 명령어가 가지는 인수들의 개수를 의미한다.
  * argv[]는 명령어가 가지는 인수들을 문자열 형태로 전달한다.

#### 프로그램 실행형태

1. 만든 프로그램은 최종적으로 확장자가 exe인 실행파일이 되어 하드디스크에 저장된다.
2. DOS 창에서 이 프로그램의 이름을 입력하면 프로그램을 실행시킬 수 있다.

* 예제를 통한 설명

  ```
  C: \cprogram> mycopy src dst
  ```

  * 이 경우 운영체제는 src와 dst라는 명령 인수를 프로그램으로 전달할 것이다.

    * 전달하는 방법은 argc와 argv를 통해서 전달한다.

      * argc는 명령어 행에 존재하는 모든 단어들의 개수를 전달한다.

      * argv[] 배열의 원소들은 명령어 행에 있는 인수들의 주소를 가지게 된다.

        main 함수에서는 argv[] 배열을 통해 명령어 행에서 입력된 인수들을 알 수 있다.

