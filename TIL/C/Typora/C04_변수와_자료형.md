# Chapter4 : 변수와 자료형

* 학습목표
  * 변수와 상수의 개념을 이해한다.
  * C에서 사용가능한 변수의 종류를 알고 있다.
  * 정수형 변수와 상수를 선언하고 사용할 수 있다.
  * 부동 소수점형 변수와 상수를 선언하고 사용할 수 있다.
  * 기호 상수를 사용할 수 있다.
  * 오버플로우와 언더플로우를 이해한다.

<br><br>

### 4.1 변수와 상수

프로그램에서 데이터를 저장할 수 있는 공간을 변수와 상수로 나눌 수 있다.

#### 변수

```
프로그램이 실행되는 동안 데이터 값들이 일시적으로 저장되고 저장된 데이터값이 변경될 수 있는 공간을 변수라고 한다.
```

* 일시적인 이유는 변수에 담겨있는 데이터들은 프로그램이 종료되면 사라지기 때문이다.
* 프로그램은 데이터를 임시로 저장할 공간이 반드시 있어야한다.
  * 데이터의 값을 저장해야 나중에 불러와 연산이나 출력을 할 수 있기 때문
* 데이터의 값이 한번 저장되었어도 언제든지 다시 다른 값으로 변경이 가능하다.

##### 변수의 상자표현

* 변수를 상자로 이해
  * 상자의 이름을 변수의 이름으로 표현한다
  * 안의 공간을 변수로 표현한다.
    * 상자의 크기는 데이터의 종류에 따라 다르게 표현

##### 변수와 메모리

* 변수는 물리적으로 메인 메모리에 만들어진다. 
  * 프로그램안에서 변수를 만들고 이름을 부여하고, 변수 이름을 사용하여 메모리 공간을 사용함
    * 변수를 사용하지 않으면 메모리의 주소를 가지고 데이터를 저장해야함.

#### 상수

```
값이 한번 정해지면 프로그램이 실행되는 동안 값이 변경되지 않는 데이터의 공간
```

* 상수도 변수와 동일하게 메모리에 저장되며 자료형을 가지고 있음. 

##### 리터럴 상수

```c
3.141592
```

* 위와 같이 이름이 없는 상수를 의미

##### 기호 상수

```c
#define PI 3.141592
```

* 위와 같이 기호로 정의된 함수를 의미
* 보통 전처리기 아래, main 함수 위에 사이에 정의된다.
* 이후 모든 PI기호가 정의된 상수를 의미
* 코드의 수정/보완이 용이하고 가독성을 높여준다.

<br>

### 4.2 자료형

#### 자료형의 개념

```
데이터의 종류를 자료형, 데이터 타입이라고 표현한다.
```

* 자료형에 따라서 저장하는데 필요한 메모리 공간의 크기가 다르기 때문에 효율적인 메모리 사용을 위해서는 자료형에 따라 변수의 종류를 다르게 해야한다.

#### 자료형의 종류

정수형(integer type), 부동 소수점형(floating-point type), 문자형(character type)으로 나눔.

| 정수형               | 부동 소수점형              | 문자형           |
| -------------------- | -------------------------- | ---------------- |
| 정수타입 데이터 저장 | 실수타입 데이터 저장       | 하나의 문자 저장 |
| short, int long      | float, double, long double | char             |

* 문자형은 정수로 분류하기도 한다. 문자가 작은 정수로 표현되기 때문이다.

#### 자료형의 크기

각  자료형의 크기를 알아보려면 sizeof 연산자를 사용하면 된다.

* sizeof()

  * 변수나 자료형의 크기를 바이트 단위로 반환하는 연산자

* sizeof.c

  ```c
  #include <stdio.h>
  
  int main(void)
  {
      int x;                                                                                                          
      printf("size of variuos x: %d\n", sizeof(x));
  
      printf("\nsize of char: %d\n", sizeof(char));
      printf("size of int: %d\n", sizeof(int));
      printf("size of short: %d\n", sizeof(short));
      printf("size of long: %d\n", sizeof(long));
      printf("size of flaot: %d\n", sizeof(float));
      printf("size of double: %d\n", sizeof(double));
      printf("size of long double: %d\n", sizeof(long double));
  
      return 0;
  }
  ```

* 실행결과

  * 경고(실행)

    ```
    size of variuos x: 4
    
    size of char: 1
    size of int: 4
    size of short: 2
    size of long: 8
    size of flaot: 4
    size of double: 8
    size of long double: 16
    ```

    * 경고메시지

      ```
      warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wforma
      t=]
      printf("size of int: %d\n", sizeof(int));
      ```

      * 인수 2인 sizeof가 unsigned int로 int의 범위밖의 수가 나올수 있어서  **오버플로우가 발생할 수 있기때문에 경고를 출력**했다.

  * 디버깅

    ```c
    #include <stdio.h>
    
    int main(void)
    {
        int x;
        printf("size of variuos x: %ld\n", sizeof(x));
    
        printf("\nsize of char: %ld\n", sizeof(char));
        printf("size of int: %ld\n", sizeof(int));
        printf("size of short: %ld\n", sizeof(short));
        printf("size of long: %ld\n", sizeof(long));
        printf("size of flaot: %ld\n", sizeof(float));
        printf("size of double: %ld\n", sizeof(double));
        printf("size of long double: %ld\n", sizeof(long double));
    
        return 0;
    }
    ```

    *  sizeof로 인한 오버플로우가 발생하지 않게 %ld의 형태로 쓴다.

  * 실행

    ```
    size of variuos x: 4
    
    size of char: 1
    size of int: 4
    size of short: 2
    size of long: 8
    size of flaot: 4
    size of double: 8
    size of long double: 16
    ```

<br>

### 4.3 변수의 이름 짓기

변수의 이름은 마음대로 지을 수 있지만 몇가지 규칙(식별자)을 지켜야 한다.

#### 식별자

**변수 이름, 함수 이름 등에 사용되어서 다른 것들과 식별할 수 있게 해주는 것**

##### 식별자의 규칙

* 식별자는 영문자와 숫자, 밑줄 문자_로 이루어져있다.

* 식별자 중간에 공백이 들어가면 안된다.

* 식별자의 첫 글자는 반드시 영문자 또는 밑줄 기호_이어야 한다. 식별자는 숫자로 시작할 수 없다.

* 대문자와 소문자는 구별된다.

* C언어의 키워드와 똑같은 식별자는 허용되지 않는다.

  * 키워드(예약어)는 C언어에서 고유한 의미를 가지는 특별한 단어이다. 사용자가 다시 정의하거나 사용하는 것이 금지되어 있다.

    * C언의 키워드 종류

      | auto         | break        | case         | char       |
      | ------------ | ------------ | ------------ | ---------- |
      | **const**    | **continue** | **default**  | **do**     |
      | **double**   | **else**     | **enum**     | **extern** |
      | **float**    | **for**      | **goto**     | **if**     |
      | **int**      | **long**     | **register** | **return** |
      | **short**    | **signed**   | **sizeof**   | **static** |
      | **struct**   | **switch**   | **typedef**  | **union**  |
      | **unsigned** | **void**     | **volatile** | **while**  |

      * C언어는 다른 언어와 비교해 키워드가 적다.
      * 컴파일러나 시스템에 따라 키워드가 추가될 수 있다.

#### 좋은 변수 이름

* 변수의 이름 설정은 아주 중요한 작업임으로 신중해야하고, 시간을 투자해야 한다. 변수를 잘 설정하면 개발자나 사용자가 전체 프로그램을 쉽게 이해할 수 있게 해준다.
* 한글 변수 이름도 지원하는 컴파일러도 있으나 지원하지 않는 컴파일러도 많기 때문에 영문 이름으로 변수를 설정하는 것이 적절하다.

##### 밑줄문자를 이용한 변수설정

* bank_account

##### 대문자를 이용한 변수설정

* BankAccount

<br>

### 4.4 변수 선언과 사용

```
변수는 사용하기 전에 반드시 미리 선언(declare)하여야 한다.
```

#### 변수선언

```
컴파일러에게 어떤 변수를 사용하겠다고 이미 알리는 것
```

* 변수 선언의 이유
  * 컴파일러는 변수를 저장하는 메모리 공간을 미리 확보한다.
  * 산술연산을 비롯하여 변수에 가해지는 각종 연산들이 올바르게 실행하도록 컴파일러에 알려준다.

##### 변수 선언 방법

* 원하는 자료형을 먼저 쓰고 다음에 변수 이름을 쓰면 된다.

* 문장의 끝엔 세미콜론을 쓴다.

  ```c
  int/*(자료형)*/ variable/*(변수이름)*/;
  ```

* 여러개의 같은 유형의 변수를 한줄에 선언할 수 있다.

  ```c
  int width, height;
  ```

##### 변수 초기화

* 변수를 선언과 동시에 초기 값을 적어 넣는것

  ```c
  int i = 0;
  ```

* 여러개의 같은 유형의 변수를 한줄에 선언과 초기화 할 수 있다.

  ```c
  int width = 10, height = 200;
  ```

* 변수를 초기화 시키지 않는다면 초기화되지 않은 변수에는 일반적으로 쓰레기값이 들어가게 된다.

##### 변수 선언 위치

* C언어에서 변수는 반드시 함수의 시작 부분에서 선언되어야 한다.

  * 옛날엔 컴파일 오류가 발생했으나 지금의 C버전에서는 발생하지 않는다. 하지만 함수의 문장은 순차적으로 실행되므로 처음 선언하는 경우가 오류를 방지할 수 있다.

    * error01.c Code

    ```c
    #include <stdio.h>
    
    int main(void)                                                                                                          
    {
        int i;
        printf("Hello World!\n");
    
        int sum;
    
        return 0;
    }
    ```

    * 실행

      ```
      Hello World!
      ```

##### 변수의 사용

*  변수에는 대입 연산자를 통해 값을 저장하고 바꿀 수 있다.
*  변수에는 다른 변수의 값도 대입할 수 있다.

<br>

### 4.5 정수형

자료형중 하나의 정수형은 수학에서와는 다르게 비트에 할당된 정수만 표현할 수 있다.

| 부호여부 | 자료형         | 설명                   | 바이트 수 | 범위                   |
| -------- | -------------- | ---------------------- | --------- | ---------------------- |
| O        | short          | short형 정수           | 2         | -32768~32767           |
| O        | int            | 정수                   | 4         | -2147483648~2147483647 |
| O        | long           | long형 정수            | 4         | -2147483648~2147483647 |
| X        | unsigned short | 부호 없는 short형 정수 | 2         | 0~65535                |
| X        | unsigned int   | 부호 없는 정수         | 4         | 0~4294967295           |
| X        | unsigned long  | 부호 없는 long형 정수  | 4         | 0~4294967295           |

* 여러가지 타입의 정수가 있는 이유는 필요에 따라 적당한 크기의 정수형을 선택해 메모리 사용의 효율을 높이기 위해서이다.

#### int형

* 32bit가 일반적이나 최근엔 64bit로 지원하는 경우도 많아졌다
  * CPU의 효율이 좋아져 64bit의 메모리를 한번에 읽을 수 있고 int의 크기가 이와 관련있기 때문이다.

#### unsigned, signed 수식자

* 모든 정수형 앞에 올 수있다
* unsigned 는 음수가 아닌 값만 나타낸다는 것을 의미하고, signed는 음수도 가능하다는 것을 의미하고 생략도 가능
* unsigned의 경우 %u를 사용한다.
  * %d를 사용해도 되지만 값이 커지면 오버플로우가 발생해 음수를 출력한다.

#### 오버플로우

```
변수가 나타낼 수 있는 범위를 넘는 숫자를 저장하려고 할때 발생. 값의 최대,최소범위로 돌아감.
```

* overflow.c Code

  ```c
  #include <stdio.h>
  #include <limits.h>
  
  int main(void)
  {
          short s_money = SHRT_MAX;
          unsigned short u_money = USHRT_MAX;
  
          printf("s_money = %d\n", s_money);
          s_money = s_money + 1;
          printf("s_money = %d\n\n", s_money);
  
          printf("u_money = %d\n", u_money);
          u_money = u_money + 1;
          printf("u_money = %d\n", u_money);
  
          return 0;
  }
  ```

  * 실행 결과

    * 실행

    ```
    s_money = 32767
    s_money = -32768
    
    u_money = 65535
    u_money = 0
    ```

    * limits.h
    * 각 자료형의 최대, 최솟값은 limits.h에 정의되어 있다.

* 오버플로우가 발생해도 컴파일러는 아무런 경고를 하지 않기 때문에 프로그래머 스스로 주의 하여야 한다.

#### 정수 상수

* 정수 상수는 기본적으로 int형으로 간주, 값의 범위를 넘으면 long, unsigned long형으로 변경될 수 있다.

  * 컴파일러는 자동적으로 가능한 자료형 중 가장 작은 자료형을 선택한다.

  * 상수의 자료형을 프로그래머가 명시적으로 지정하고 싶은 경우 정수 상수 뒤에 접미사로 L을 붙이면 된다.

    * 정수 상수의 예

      |   접미사   |    자료형     |        예        |
      | :--------: | :-----------: | :--------------: |
      |  u 또는 U  | unsigned int  |  123u 또는 123U  |
      |  l 또는 L  |     long      |  123l 또는 123L  |
      | ul 또는 UL | unsigned long | 123ul 또는 123UL |

  * 정수상수의 표기법

    |               |   10진수    | 형식 지정자 |   8진수    | 형식 지정자 | 16진수      | 형식 지정자 |
    | :-----------: | :---------: | :---------: | :--------: | ----------- | ----------- | ----------- |
    |     입력      |     10      |             |   010(8)   |             | 0x10(16)    |             |
    |     의미      | 10진수로 10 |             | 8진수로 10 |             | 16진수로 16 |             |
    |     출력      |     10      |     %d      |     10     | %o          | 10          | %x          |
    | 진수표시 출력 |     10      |     %d      |    010     | %#o         | 0x10        | %#x         |

#### 기호 상수

기호에 의하여 상수를 표현하는 것으로 리터럴 상수에 비해 프로그램을 읽기 쉽고 수정, 변경이 용이하다.

* \#define  문장 사용

  컴파일러가 동작하기 전에 전처리기가 처리하는 기호 상수

| 형식 |        \#define 기호상수 값        |
| :--: | :--------------------------------: |
| 설명 | 값을 나타내는 기호 상수를 정의한다 |
|  예  |    \#define EXCHANGE_RATE 1120     |

* const 키워드 사용

  변수 선언 앞에 const를 붙이면 상수가 되고 초기화 한 후 그 값을 변경할 수 없다

| 형식 |                  자료형 변수이름 = 초기값                   |
| :--: | :---------------------------------------------------------: |
| 설명 | const를 사용하면 값을 변경할 수 없는 변수를 정의할 수 있다. |
|  예  |               const int EXCHANGE_RATE = 1120;               |

*  const 키워드를 더 잘 쓰는 이유
   * 자료형을 지정할 수 있고 상수가 정의되는 범위를 변수와 같이 제한할 수 있다. 그리고 배열이나 구조체와 같은 복합 데이터 타입에도 const는 사용할 수 있다.

#### 내부적인 정수 표현 방식

* 내부적으로 정수는 2진표현 방식을 사용한다.

  * 하나의 비트는 0,1로 두가지 상태만 표시할 수 있으나 2개의 비트는 00, 01, 10, 11 4가지 상태로 표시할 수 있다.
  * 이렇게 short,long등의 정수 자료형들은 정수를 하나의 상태로 표현하게 된다.

* 10진수와 2진수

  * 10진수는 2진수로 표현하기 위해 2로 나누고 역순으로 쓴다.

* 보수를 이용한 음수표현

  컴퓨터는 뺄셈이나 음수를 표현할 때 보수를 사용한다.

  * 컴퓨터는 보수를 이용해서 계산을 하지 않으면 복잡한 계산을 해야한다.

  ```
  보수는 자릿수가 변하기 위해 필요한 수를 의미함.
  숫자를 표현하는 진수의 보수라고 부름. (10의보수, 2의보수 ... )
  ```

  * 9908(10진수)의 10의 보수는 0092

  ```
  n-1의 보수는 자리수가 변하지 않는 최댓값이 되기 위해 필요한 수를 의미함.
  ```

  * 9908(10진수)의 9의 보수는 0091

<br>

### 4.6 부동 소수점형

#### 컴퓨터에서 실수를 나타내는 방식

##### 고정 소수점(fixed point)

* 소수점위치를 고정시키고 정부수와 소수부에 각각 일정 비트를 할당해 표현하는 방식

  ```
  정수부 16, 소수부 16를 나눠 표현
  ex) 12.5 를 고정 소수점 방식으로 표현하면 0000000000000110.1000000000000000
  ```

  * 가당 단순하고 알기 쉽지만 매우 큰수나 매우 작은수를 표현할 수 없다.

##### 부동 소수점(floating point)

* 고정 소수점의 단점을 보완하기 위해 나온 방식으로 부동 소수점방식이란 소수점이 떠서 움직인다는 뜻이다.

* 가수부와 지수부로 나눠서 비트를 할당하는 방식

  ```
  부호 1, 가수부 23, 지수부 8
  ex) 15.12를 부동 소수점으로 바꾸면 1.512e1
  ```

#### 부동 소수점 자료형

|       자료형        |                   명칭                   |  크기  |         할당         |             범위             |
| :-----------------: | :--------------------------------------: | :----: | :------------------: | :--------------------------: |
|        float        | 단일정밀도(single-precision) 부동 소수점 | 32비트 | 가수부 24, 지수부 8  |  +_1.17549e-38~+_3.40282e38  |
| double, long double | 두배정밀도(double-precision) 부동 소수점 | 64비트 | 가수부 53, 지수부 11 | +_2.22507e-308~+_1.79769e308 |

#### 실수를 출력하는 형식 지정자

* 기본적인 형식 지정자는 %f이다.

* 소수점 6자리까지만 출력되고 이를 넘으면 반올림된다.

* 실수의 소수점 자릿수를 제한하려면 %a.bf 형식을 사용한다.

  * 전체 a자리 중에서 소수점 이하를 b자리 이하로 하라는 의미이다.
    * %10.3f는 전체 10자리중에 소수점 이하를 3으로 하라.

* 실수를 지수표기법으로 출력하려면 %e, %E를 사용한다.

  * %e면 e로 표현, %E면 E로 표현함

* %g를 사용하면 소수점 이하 6자리 안에서 표현가능하면  %f, 그렇지 않으면  %e방식으로 표현함.

* floating.c Code

  ```c
  #include <stdio.h>
  
  int main(void)
  {
      float x = 1.234567890123456789;
      double y = 1.234567890123456789;
  
      printf("float size = %ld\n", sizeof(float));
      printf("double size = %ld\n", sizeof(double));
  
      printf("x = %30.25f\n",x);
      printf("y = %30.25f\n",y);
  
      return 0;
  }
  ```

* 실행결과

  * 실행

    ```
    float size = 4
    double size = 8
    x =    1.2345678806304931640625000
    y =    1.2345678901234566904321355
    ```

    * 부동소수점 방식은 유효숫자에 제한이 있기 때문에 정확한 값을 표현할 수 없을 수 있다.

#### 부동소수점 상수

* 부동소수점 상수는 기본적으로 double형으로 표현되며 상수 끝에 f, F를 붙이면 float형의 상수를 만들 수 있다.

* 부동소수점 상수는 지수 표기법으로도 표현 가능하다

* 12345.6을 지수 표기법으로 표현하면 1.23456e4

* 유효한 부동 소수점 예

  | 1.23456 |            설명             |
  | :-----: | :-------------------------: |
  |   2.    |     소수점만 붙여도 됨      |
  |   .28   |    정수부를 생략해도 됨     |
  |  2e+10  | 지수부에 부호를 사용해도 됨 |
  | 9.26E3  |   e대신 E를  사용해도 됨    |

#### 오버플로우와 언더플로우

* 오버플로우

  변수에 대입된 수가 너무 커서 변수가 저장할 수 없는 상황

  inf로 표기하고 무한대임을 나타냄

  * over.c Code

  ```c
  #include <stdio.h>
  
  int main(void)
  {
          float x = 1e39;
          printf("x = %e\n", x);
          return 0;
  }
  ```

  * 실행결과

    * 실행

    ```
    x = inf
    ```

* 언더플로우

  부동 소수점 수가 너무 작아서 표현하기가 힘든상황

  값이 너무 작은 경우 가수부를 조정해서 불확실한 값을 만드는 경우 발생

  * under.c Code

    ```c
    #include <stdio.h>
    
    int main(void)
    {
        float x = 1.23456e-38;
        float y = 1.23456e-40;
        float z = 1.23456e-46;
    
        printf("x = %e\n", x);
        printf("y = %e\n", y);
        printf("z = %e\n", z);
    
        return 0;
    }
    ```

  * 실행결과

    * 실행

      ```
      x = 1.234560e-38
      y = 1.234558e-40
      z = 0.000000e+00
      ```

  * 가수부를 조정하여 맞추는 과정도 한계에 다르면 0으로 출력됨

#### 부동 소수형을 사용할 경우 주의할 점

* 부동 소수형 연산은 정확하지가 않는 경우가 많다.

  * miss.c Code

    ```c
    #include <stdio.h>
    
    int main(void)
    {
            double x;
    
            x = (1.0e20 + 5.0) - 1.0e20;
            printf("%f \n", x);
    
            return 0;
    }
    ```

  * 실행결과

    * 실행

      ```
      0.000000
      ```

  * 부동 소수점 연산은 유효숫자를 넘어가면 정확한 연산이 불가능하다.

<br>

### 4.7 문자형

#### 문자와 아스키코드

* 문자

  한글이나 영어에서의 하나의 글자, 숫자, 기호 등을 의미한다.

  * 컴퓨터에서도 문자를 숫자로 표현하지만 그 숫자의 값이 문자를 지정한다.

* 아스키(ASCII)코드

  * 1967년에 만들어진 것으로 알파벳에 기초를 둔 문자 인코딩 방법이다.
  * 33개의 인쇄가 불가능한 제어 문자코드와 95개의 인쇄 가능한 문자코드가 있다.
  * 127~255코드는 확장 아스키 코드들이 있다.
  * 알파벳 순서대로 정의되어 있고, '1'과 1은 같지않다.

* 유니코드

  전 세계의 문자를 모두 표현하기 위해 사용되는 문자규격으로 2바이트를 사용함.

#### 문자 변수와 문자 상수

​	문자 변수를 표현하는 방법은 아스키코드 값으로 표현하는 방법과 문자 상수로 표현하는 두가지 방법이 있다.

* char_var.c Code

  ```c
  #include <stdio.h>
  
  int main(void)
  {
          char code1 = 'A';
          char code2 = 65;
      
          printf("clear of constant text :%c\n", code1);
          printf("clear of constant ASCII : %c\n", code2);
  
          return 0;
  }
  ```

* 실행결과

  * 실행

    ```
    clear of constant text :A
    clear of constant ASCII : A
    ```

* 문자상수

  * 작은따옴표로 감싸서 표현.
  * ASCII코드를 다 외우지 않아도 문자를 사용해 표현할 수 있다는 장점이 있다.

* char의 정수형과 문자형

  * 형식 지정자에 따라 다름
    * %d는 정수형으로 출력, %c는 문자형으로 출력함.

#### 제어 문자

인쇄될 수 없고 제어 목적으로 이용되는 문자이고 작은 따옴표를 이용해도 출력할 수 없다.

* 제어문자를 표현하는 방법

  * 아스키코드 사용

  * 이스케이프 시퀀스(escape sequence)

    역슬래시( \ )와 의미를 나타내는 한 글자를 붙여서 제어 문자를 표현할 수 있다.

    | 제어문자 | 이름                         | 의미                                                      |
    | -------- | ---------------------------- | --------------------------------------------------------- |
    | \0       | 널문자                       |                                                           |
    | \a       | 경고(bell)                   | "삐"하는 경고음 발생                                      |
    | \b       | 백스페이스(backspace)        | 커서를 현재의 위치에서 한 글자 뒤로 옮긴다.               |
    | \t       | 수평탭(horizontal tab)       | 커서의 위치를 현재 라인에서 설정된 다음 탭 위치로 옮긴다. |
    | \n       | 줄바꿈(newline)              | 커서를 다음 라인의 시작 위치로 옮긴다.                    |
    | \v       | 수직탭(vertical tab)         | 설정되어 있는 다음 수직 탭 위치로 커서를 이동             |
    | \f       | 폼피드(form feed)            | 주로 프린터에서 강제적으로 다음 페이지로 넘길때 사용된다. |
    | \r       | 캐리지 리턴(carriage return) | 커서를 현재 라인의 시작 위치로 옮긴다.                    |
    | \\"      | 큰따옴표                     | 원래의 큰 따옴표 자체                                     |
    | \\'      | 작은따옴표                   | 원래의 작은따옴표 자체                                    |
    | \\\      | 역슬래시(back slash)         | 원래의 역슬래시 자체                                      |

* escape.c Code

  ```c
  #include <stdio.h>
  
  int main(void)
  {
          int id, pass;
  
          printf("Input Id and password within 4 number:");
          printf("id:____\b\b\b\b");
          scanf("%d", &id);
          printf("password:____\b\b\b\b");
          scanf("%d", &pass);
          printf("\aID is \"%d\" password is \"%d\"", id, pass);
  
          return 0;
  }
  ```

* 실행결과

  * 실행

    ```
    Input Id and password within 4 number:id:1234
    password:5678
    ID is "1234" password is "5678"
    ```

#### 정수형으로서의 char형

char형는 사실 8비트의 정수를 저장하는 자료형이다.

|    자료형     |          설명          | 바이트 수 |   범위   |
| :-----------: | :--------------------: | :-------: | :------: |
|     char      |      문자 및 정수      |     1     | -128~127 |
| unsigned char | 문자 및 부호 없는 정수 |     1     |  0~255   |

* char.c Code

  ```c
  #include <stdio.h>
  
  int main(void)
  {
          char code = 'A';
  
          printf("%d %d %d\n", code, code+1, code+2);
          printf("%c %c %c\n", code, code+1, code+2);
  
          return 0;
  }
  ```

* 실행결과

  * 실행

    ```
    65 66 67
    A B C
    ```

#### 예제

* sunslight.c Code

  ```c
  #include <stdio.h>
  
  int main(void)
  {
          double sunspeed = 300000.0;
          double distance = 149600000.0;
          double time;
          int times, minute, second;
  
          printf("sunspeed is %lf km/s\n", sunspeed);
          printf("distance between earth and sun is %lf km\n", distance);
  
          time = distance / sunspeed;
  
          times = time;
          minute = times / 60;
          second = times % 60;
  
          printf("%lfseconds, or %d minute %d second", time, minute, second);
  
          return 0;
  }
  ```

* 실행결과

  * 실행

    ```
    sunspeed is 300000.000000 km/s
    distance between earth and sun is 149600000.000000 km
    498.666667seconds, or 8 minute 18 second
    ```

* 소수점을 지우기 위해 값을 int에 저장함.

  ```c
  times = time;
  minute = times / 60;
  second = times % 60;
  ```


<br>