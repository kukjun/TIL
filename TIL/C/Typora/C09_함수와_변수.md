# Chapter09 함수와 변수

* 변수가 선언되는 위치에 따라 변수의 범위, 생존시간, 연결 등이 어떻게 달라지는지를 이해한다.
* 저장 유형 지정자에 따라 변수의 속성이 어떻게 변경되는지를 학습한다.
* 자기 자신을 호출하는 순환 호출의 개념과 응용 예를 살펴본다.

## 9.1 변수의 속성

* 변수는 함수 외부와 내부에서 서로 큰 차이가 있다.
* 변수는 이름, 타입, 크기, 값 등을 기본 속성으로 갖지만 **범위, 생존 시간, 연결**과 같은 속성도 가진다.
* 변수는 선언하는 위치나 여러 가지 저장 유형 지정자(storage class specifier)를 사용하여 이들 속성을 변경할 수 있다.

### 1. 범위(scope)

```
변수가 어떤 범위에서 사용이 가능한가를 뜻한다.
```

* 가시성(visivility)라고도 한다.
* 프로그램에 일부분에서만 참조 가능한 변수가 있는 반면, 프로그램 전체에서 참조할 수 있는 변수도 있다.
  * 범위는 주로 변수가 정의되는 위치에 따라서 결정된다.
    * 변수가 블록안에 정의되면 블록 안에서만 사용할 수 있다.
    * 변수가 함수 밖에 있으면 전체 파일에서 이 변수를 사용할 수 있다.

### 2. 생존 시간(life time)

```
변수가 메모리상에 얼마나 오랫동안 존재하는지를 뜻한다.
```

* 함수는 선언되는 위치에 따라 잠깐 생존하였다가 없어지기도 한다.

### 3. 연결(linkage)

```
서로 다른 영역에 있는 변수들을 연결한는데 사용되는 속성이다.
```

## 9.2 범위

* 변수는 범위에 따라 전역변수와 지역변수로 나뉜다.
* 지역 변수(local variable)
  * 함수 또는 블록 안에서 정의되는 변수.
  * 지역 변수는 해달 블록이나 함수 안에서만 사용 가능하다.

* 전역 변수(global variable)
  * 함수의 외부에서 선언되는 변수
  * 전역 변수는 소스파일의 어느 곳에서도 사용이 가능하다.

## 9.3 지역 변수

```
블록 안에서 선언되는 변수
```

* 함수의 몸체도 블록이므로 함수 안에서 선언되는 함수도 지역함수이다.

### 1. 지역 변수의 선언 위치

* 지역 변수는 블록의 맨 첫 부분에서 정의되어야 한다.
  * 컴파일러가 알아보기 쉽고, 개발자가 이해하기 쉽도록 하기 위해서이다.
    * 현재는 밑에서 선언해도 컴파일 오류가 발생하지 않는다.

### 2. 지역 변수의 범위

* 지역 변수는 변수가 선언된 블록 안에서만 접근과 사용이 가능하다.

### 3. 이름이 같은 지역 변수

* 동일한 이름의 변수라도 들어있는 블록이 다르면 컴파일 오류가 발생하지 않는다.

### 4. 지역 변수의 생존 시간

* 지역 변수는 블록이 시작할 때 스택(stack)이라 불리는 메모리 공간에서 만들어진다.
  * 지역 변수에 할당된 메모리 공간은 블록 끝에서 반환된다. 이때, 지역변수도 사라지게 된다.
    * 반복문 안에서 만들어진 변수도 사라진다.

### 5. 지역 변수의 초기값

* 지역변수의 경우 초기값을 정해주지 않으면 컴파일러에 따라 다른 반응을 한다.
  * gcc : 0으로 초기화, 연산도 가능
  * vs : 컴파일 오류

### 6. 함수의 매개 변수

* 함수의 헤더 부분에 정의되어 있는 매개 변수도 일종의 지역 변수이다.

  * 지역변수의 특징을 가지고 있으나, 함수 호출 시 인수 값으로 초기화 되어있다는 점이 다르다.

  * 341p.c Code

    ```c
    +#include <stdio.h>
    int inc(int counter);
    int main(void)
    {
    	int i = 10;
        inc(i);
        printf("i = %d", i)
    }
    
    int inc(int counter)
    {
        counter++;
        return counter;
    }
    ```

    * 위 코드에서 counter가 매개 변수이고 동시에 지역 변수이다.
      * counter는 함수가 시작되면 생성되고 함수가 종료되면 소멸된다.
      * counter엔 i의 복사본이 전달되므로 i값은 변하지 않는다.
        * 값에 의한 호출(call by value)
          * 참조에 의한 호출(call of reference)

## 9.4 전역 변수

```
함수 외부에서 선언되는 변수.
```

* 342p.c

  ```c
  #include <stdio.h>
  
  int x = 123;
  
  void sub1()
  {
  	printf("In sub1(), x= %d\n", x);
  }                                                                                          
  void sub2()
  {
      printf("In sub2(), x= %d\n", x);
  }
  int main(void)
  {
      sub1();
      sub2();
      return 0;
  }
  ```
  * 실행 결과

    * 실행

      ```
      In sub1(), x= 123
      In sub2(), x= 123
      ```



### 1. 전역 변수의 초기값과 생존 기간

* 전역 변수를 초기화 하지 않으면 컴파일러에 의하여 0으로 초기화된다.
* 전역 변수는 프로그램의 시작과 동시에 생성되며 프로그램이 종료되기 전까지 메모리에 존재한다.
  * 프로그램 시작과 동시에 접근이 가능하며 종료되기 전까지 전체 영역에서 접근이 가능하다.

### 2. 전역 변수의 사용

* 전역 변수는 편리할 것 같지만, 사용을 권하지 않는다.
  * **어디서나 접근이 가능하다는 것은 단점이 될수도 있음**
    * 함수들이 복잡하게 섞임(spaghetti code)
    * 전역변수를 변경하는 부분을 찾기 힘듬
    * 전역 변수를 변경하면, 다른 함수도 변경해야함.

* 모듈화 프로그래밍

  ```
  프로그램을 특정 작업을 수행하는 독립된 모듈로 분류하는 것
  ```

  * 함수는 자신의 작업에 필요한 데이터와 코드를 모두 포함하여야 한다.
    * 전역 변수를 사용하면 함수밖의 데이터를 사용하므로 각 모듈의 독립성을 위반한다.

* 상황에 따라 전역변수를 두는 편이 효율성을 위하여 좋을 수 있다.
  * 거의 모든 함수에서 사용하는 공통적인 데이터는 전역 변수로 한다.
  * 일부의 함수들만 사용하는 데이터는 전역 변수로 하지말고 함수의 인수로 전달한다.

### 3. 같은 이름의 전역 변수와 지역 변수

* 지역변수와 전역변수의 이름이 같으면 지역 변수가 전역 변수보다 우선시된다.
  * 지역변수가 전역변수를 가린다고 표현한다.

## 9.5 생존 시간

* 변수가 생존할 수 있는 시간을 의미하며, 생존 시간에 따라 변수를 정적 할당과 자동 할당으로 나눌 수 있다.

#### 1) 정적 할당(static allocation)

* 프로그램이 실해오디는 동안에는 계속하여서 변수에 저장 공간이 할당되어 있는 방법이다.

#### 2) 자동 할당(automatic allocation)

* 블록이 시작되면서 변수에 저장 공간이 할당되고 블록이 종료되면 저장 공간이 회수되는 방법이다.

#### 3) 생존시간 결정 요인

* **변수의 범위와 생존시간은 다른 의미이다.**

##### a) 변수 선언 위치

* 전역 변수는 정적 할당되고 지역변수는 기본적으로 자동 할당된다.
  * **지역 변수 앞에 저장 유형 지정자를 붙이면 정적 할당으로 변경할 수 있다.**

##### b) 저장 유형 지정자

* 변수를 선언할 때 붙일 수 있는 저장 유형을 지정하는 수식어
  * auto, register, static, extern등이 있다.
* 변수나 함수를 선언할 때 어디에 지정되는지를 지정한다.

### 1. auto 지정자

* 함수나 블록 내에 선언되는 지역변수는 기본적으로 자동 할당이 된다.
  * 이러한 지역 변수를 자동 변수(auto variable)라고 한다.

* 원칙적으로는 auto 키워드를 붙여야 하지만 함수나 블록 안의 변수에는 auto가 생략되어도 모두 자동변수로 취급한다.

### 2. static 지정자

* 지역변수를 블록밖에서도 자동적으로 제거되지 않는 변수로 만들려면?
  * 지역변수를 정적 변수(static variable)로 만든다.

#### 1) 정적변수를 지역 변수에 사용하는 경우

* 정적 변수의 생성과 제거는 자동 변수와 대조된다.
  * 정적 변수는 전역번수와 같이 프로그램이 시작할때 메모리에 생성되고 프로그램이 종료되면 메모리에서 제거된다.
  * static 지정자로 만들어진 정적변수는 다른 함수에서 접근할 수 없다.

### 3. register 지정자

* 변수를 레지스터 변수(register variable)로 만드는 지정자.

  * 변수를 메모리 뿐만 아니라 레지스터에도 저장한다.
    * 레지스터는 CPU만 사용하고 CPU의 일부분이기 때문에 데이터를 읽고 쓰는 속도가 아주 빠르다.

  * 레지스터는 CPU에 따라 다르지만 일반적으로 개수가 제한되어 있다. 그래서 할당이 불가능한 경우, 컴파일러에 의해 레지스터 선언이 무시될 수 있다.

* 레지스터 변수를 적절히 사용하면 프로그램의 실행속도를 빠르게 한다.
  * 특히 루프를 제어하는 변수를 레지스터로 하면 많은 성능향상을 가져올 수 있다.
    * 최근 컴파일러는 CPU의 레지스터를 적절하게 사용하고 있어 크게 신경쓸 필요 없다.

* 레지스터 변수에는 주소를 추출하는 연산자 &를 적용하면 컴파일 오류가 발생
  * 레지스터는 주소가 없다.

### 4. extern 지정자

* 함수나 변수의 연결을 도와주는 지정자

## 9.6 연결

```
연결(linkage)이란 다른 범위에 속하는 변수들을 서로 연결하는 것을 의미한다.
```

* C에서는 각 변수는 무연결, 내부 연결, 외부 연결 중에 하나로 속하게 된다.
  * 무연결(no linkage) : 지역 변수로서 외부와 연결을 가지지 않는다.
  * 외부 연결(external linkage) : 전역 변수로서 여러 개의 소스 파일에 걸쳐서 사용된다.
  * 내부 연결(internal linkage) : 전역 변수로서 하나의 소스 파일에서만 사용이 가능하다.

### 1. 외부 연결

* 전역 변수를 사용하고, 여러개의 소스파일에 걸쳐 공유해야하는 경우에 사용한다.
  * 하나의 파일에서 전역 변수를 선언하고, 다른 파일에서는 extern 지정자를 사용하여 변수를 참조한다.
    * 변수를 여러 파일에서 사용할 수 있지만 <u>변수를 초기화 하는 것은 변수가 정의된 파일에서만 가능</u>하다.

* extern 키워드를 사용하지 않으면 전역 변수가 외부 연결이 가능해도 다른 소스 파일에서 참조 할 수 없다.
  * extern 키워드를 붙이면 컴파일러가 변수의 타입을 알 수 있기 때문에 컴파일이 가능하다.
    * extern으로 변수를 정의하면 저장공간이 할당되지 않고, 외부에서 선언된 변수를 사용한다.
* 하나의 전역 변수를 모든 소스 파일에서 공유하려면 보통 extern 파일 선언을 하나의 헤더 파일에 두고 이 헤더 파일을 모든 소스 파일에서 포함시키게 된다.

### 2. 내부 연결

* 전역 변수 앞에 static이 붙으면 내부 연결이 된다.
  * 하나의 소스 파일에서만 사용이 가능하다.

### 3. 함수와 static

* 함수 앞에 static이 붙는 경우, 함수는 그 소스파일 안에서만 사용이 가능하다.
  * 내부연결이 된다.
* 함수 앞에 static이 붙지 않는 경우, extern으로 선언하여 사용할 수 있다.
  * 외부연결이 된다.

## 9.7 저장유형 사용법

| 저장 유형 |  키워드  | 정의되는 위치 |       범위       | 생존 시간 |
| :-------: | :------: | :-----------: | :--------------: | :-------: |
|   자동    |   auto   |   함수 내부   |       지역       |   임시    |
| 레지스터  | register |   함수 내부   |       지역       |   임시    |
| 정적 지역 |  static  |   함수 내부   |       지역       |   영구    |
|   전역    |   없음   |   함수 외부   |  모든 소스 파일  |   영구    |
| 정적 전역 |  static  |   함수 외부   | 하나의 소스 파일 |   영구    |
| 외부 참조 |  extern  |   함수 외부   |  모든 소스 파일  |   영구    |

* 일반적으로는 자동 저장 유형을 사용하는 것이 좋다.
  * 자동 저장 유형은 프로그래머가 신경쓰지 않아도 생성되고 소멸되므로 효율적인 메모리 사용을 할 수 있다.
  * 함수나 블록을 독립적으로 만들어줄 수 있다.
* 자동 저장 유형중 자주 사용하는 변수는 레지스터 유형으로 하는 것이 좋다.
* 값이 함수의 호출이 끝나도 유지하려면 지역 정적으로 한다.
* 많이 공유되는 변수라면 외부 변수로 한다.
  * 많은 소스 파일에서 공유되어야 할 변수라면 외부 참조 변수로 만든다.

## 9.8 가변 매개 변수 함수

* 매개 변수의 개수가 호출할 때마다 달라지는 기능을 가지는 함수.
  1. 가변 매개 함수의 원형은 ...을 이용하여 선언
  2. 함수 안에서는 va_start()를 호출하여 가변 매개 변수 기능을 시작.
     * 첫 번쨰 인수는 매개 변수의 개수를 나타낸다.
  3. va_arg()를 호출할 때마다 인수들이 하나씩 반환
     * va_list 타입의 변수와 인수의 타입을 전달한다.
       * va_list는 함수 안에서 선언한다.
     * va_arg()가 반환하는 값이 인수가 된다.
  4. 인수의 개수만큼 va_arg()를 호출한다.
  5. va_end(va_list)를 호출하여서 가변 매개 변수 기능을 종료한다.

## 9.9 순환

### 1. 순환의 개념

```
함수가 자기 자신을 호출하는 경우를 순환(recursion)이라고 한다.
```

* 순환을 이용하면 이상하게 보이지만, 효과적인 프로그래밍 기법 중의 하나이다.
  * 정수의 팩토리얼 문제를 보면 n!을 정의하는데 (n-1)!이 필요하다.
    * 순환의 개념을 사용하면 쉽게 계산할 수 있다.

### 2. 순환 함수의 구조

* 순환 알고리즘은 자기 자신을 순환적으로 호출하는 부분과 순환 호출을 멈추는 부분으로 구성되어있다.
  * 순환 호출을 멈추는 부분이 없다면 시스템 스택을 다 사용할 때까지 순환적으로 호출되다가 결국 에러를 내면서 멈출 출 것이다.

### 3. 피보나치 수열의 계산

* 피보다치 수열은 구현 시에 순환 호출을 사용하는 것이 자연스러운 방법이다.

  * fib.c Code

    ```c
    #include <stdio.h>
    
    int fib(int n)
    {
        if( n==0 ) return 0;
        if( n==1 ) return 1;
        return ( fib(n-1) +fib(n-2) );
    }
    ```

    * 실행 결과는 잘 나오지만 내부가 너무 많은 연산을 하게된다.
      * 이런 피보나치 수열은 반복이 더 간단하게 프로그램을 구할 수 있다.

### 4. 하노이 탑 문제

* hanoi_tower.c

  ```c
  #include <stdio.h>
  
  void hanoi_tower(int, char, char, char);
  
  int main(void)
  {
      hanoi_tower(4, 'A', 'B', 'C');
  }
  
  void hanoi_tower(int n, char from, char tmp, char to)
  {
      if (n == 1)
          printf("circle1, from %c to %c move.\n", from, to);
      else
      {
          hanoi_tower(n-1, from, to, tmp);
          printf("cirvle%d, from %c to %c move.\n", n ,from, to);
          hanoi_tower(n-1, tmp, from, to);
      }
  ```

### 5. 2진수 형식으로 출력하기

* C엔 정수를 2진수로 출력하는 기능이 없다. 

  * print_binary.c Code

    ```c
    #include <stdio.h>
    
    void print_binary(int x);
    
    int main(void)
    {
        print_binary(9);
        return 0;
    }
    
    void print_binary(int x)
    {
        if( x > 0 )
        {
            print_binary(x / 2);
            printf("%d", x % 2);
        }
    }
    ```

### 6. 최대 공약수 구하기

* 유클리드의 호제법을 이용해 구하기

  * (x>y)일때, x, y의 최대 공약수는 y와 (x % y)의 최대 공약수와 같으며 x와 0의 최대 공약수는 x.

  * gcd.c

    ```c
    #include <stdio.h>
    
    int gcd(int x, int y);
    
    int main(void)
    {
        printf("%d\n", gcd(30, 20));
    }
    
    int gcd(int x, int y)
    {
        if( y == 0 )
            return x;
        else
            return gcd(y, x % y);
    }
    ```

