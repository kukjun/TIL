# Chapter12 문자열

### 학습목표

* 문자열이 컴푸터 내부에서 어떻게 표현되는지를 학습한다.
* 문자와 문자열을 입출력하고 처리하는 라이브러리 함수를 살펴본다.

<br>

## 12.1 문자열

**문자열(String)은 문자들의 연속이다.**

* 문자열은 큰 따옴표를 이용하여 표현된다.

  * 작은 따옴표는 문자를 표현한다.

    ```c
    A // 변수의 이름으로 간주
    'A' // 문자 A로 간주, 문자 A에 대한 아스키코드와 같다.
    "A" // 문자 A로 이루어진 문자열을 나타냄
    ```

* C언어에서는 문자열을 위한 별도의 자료형이 없는 대신 문자형 배열을 이용하여 문자열을 처리한다.

  * char형 배열을 사용해 문자열을 저장할 수 있다.

    ```c
    char str[] = "HELLO" // 로 문자열을 문자 배열로 저장하면 문자열의 끝에 \0인 NULL문자가 저장된다. 문자열의 끝은 반드시 NULL문자로 표시해줘야 한다.
    ```



### 1. NULL 문자

**NULL 문자는 아스키 코드 값이 0인 문자이다.**

NULL 문자는 \0으로 표기해도 되고 정수 0이라고 해도된다.

* 문자열의 경우 NULL 문자로 끝을 표시하지 않으면 프로그램이 문자열의 끝을 발견할 수 없다.

  ```c
  char test[10] = "Seoul";
  // S E O U L \0 이 순서대로 저장됨
  ```



### 2. 문자배열 초기화 방법

* 배열을 초기화하듯이 각 배열 원소 값들을 중괄호 안에 넣어서 초기화할 수 있다.

  ```c
  char str[4] = { 'a', 'b', 'c', '\0' }; // a b c \0
  ```

* 문자열 상수를 사용하여 초기화할 수 있다. 

  * 자동으로 NULL문자를 포함하므로 문자배열의 크기가 문자열보다 커야한다.

  ```c
  char str[4] = "abc"; // a b c \0
  ```

  * 문자배열의 크기가 충분하지 않으면 컴파일러가 경고를 하고, 일부 문자열과 NULL문자가 추가되지 않는다.

  ```c
  char str[4] = "abcdef"; // abcd만 저장, 컴파일경고 발생
  ```

  * 문자 배열의 크기가 더 크면 남는 공간들을 모두 NULL문자로 초기화한다.
    * 배열도 초기값이 없는 부분도 0으로 초기화한다.

  ```c
  char str[6] = "abc"; // a b c \0 \0 \0
  ```

  * 배열의 크기를 정하지 않으면 컴파일러가 자동으로 배열의 크기를 초기화 문자열에 맞추어 설정한다.

  ```c
  char str[] = "abc"; // 배열의 크기는 4
  ```



### 3. 문자열의 출력방법

* 반복문을 이용해 문자열에 저장된 원소를 순서대로 출력.

  ```c
  for(i=0;i<3;i++)
      printf("%c", str[i]);
  ```

* printf()에 형식 제어 문자열 %s를 사용한다. 인수는 문자배열의 이름이다.

  ```c
  printf("%s", str);
  ```

* 문자열의 경우, 그냥 문자배열을 전달하여도 된다.

  ```c
  printf(str);
  ```



### 4. 문자열의 변경

* 프로그래머가 직접 변경

  * 확실하지만 아주 불편함.

  ```c
  char str[10] = "Hello";
  str[0] = 'W';
  str[1] = 'o';
  ...
  ...
  ```

* 라이브러리 함수인 strcpy()를 사용하여 문자열을 문자 배열에 복사.

  ```c
  char str[10] = "Hello";
  strcpy(str, "World");
  ```

#### 오류

* 편리할 것 같지만 오류 발생

  ```c
  char str[10] = "Hello";
  str = "World"; // 문법적인 오류
  ```

  * 컴파일러의 입장에서 배열의 이름에 문자열을 대입하라는 의미가 된다.
    * 배열의 이름은 배열을 가리키는 주소로서 변경이 불가능하다.



### 5. 문자열 상수와 포인터

문자열 상수는 프로그램 소스 안에 포함된 값을 변경할 수 없는 문자열을 의미한다.

* 문자열 상수는 텍스트 세그먼트(text segment)라고 불리는 특수한 메모리 영역에 저장된다.

  * 텍스트 세그먼트는 읽기는 가능하지만 변경할 수 없는 메모리 영역이다.
  * 데이터 세그먼트는 값을 변경할 수 있는 메모리 영역이다.

  ```c
  char *p = "HelloWorld";
  ```

  * **포인터를 사용해 문자열을 가르킬 수도 있다.** (문자열상수)
    * 포인터를 정의하고 문자열의 주소로 포인터를 초기화한다.
      * 포인터 변수를 생성하고, 문자열 "HelloWorld"가 변경할 수 없는 메모리 영역(텍스트 세그먼트)에 저장되고, 그 메모리 주소가 반환된다. 반환된 주소는 포인터 변수 p(데이터 세그먼트)에 저장된다.

#### 문자열 변수

배열(포인터 상수)을 통해서 만들 수 있다.

```c
char str[20] = "HelloWorld";
```

* 데이터 세그먼트 영역에 저장되어 값을 변경할 수 있다.

  * stycpy()를 통해 값을 변경할 수 있다.

    ```c
    char str[20] = "HelloWorld";
    strcpy(srt, "Goodbye")
    ```

#### 문자열 상수

포인터변수를 통해서 만들 수 있다.

```c
char *p = "HelloWorld";
```

* 텍스트 세그먼트 영역에 저장되어 값을 변경할 수 없다.

* 포인터 변수이므로 p를 변경할 수 있고, 이를 이용해 임의의 주소에 새로운 문자열상수를 만들 수 있다.

  ```c
  char *p = "HelloWorld";
  p = "Goodbye"
  ```

<br>

## 12.2 문자 입출력 라이브러리

문자와 문자열은 프로그램에서 아주 많이 사용된다. 따라서 기본적인 연산들은 모두 라이브러리 함수로 지원된다.

|     입출력 함수     |                         설명                          |
| :-----------------: | :---------------------------------------------------: |
|  int getchar(void)  |            하나의 문자를 읽어서 반환한다.             |
| void putchar(int c) |           변수 c에 저장된 문자를 출력한다.            |
|  int _getch(void)   | 하나의 문자를 읽어서 반환한다.(버퍼를 사용하지 않음)  |
|  void_putch(int c)  | 변수 c에 저장된 문자를 출력한다(버퍼를 사용하지 않음) |
|   scanf("%c", %c)   |        하나의 문자를 읽어서 변수 c에 저장한다.        |
|   printf("%c", c)   |           변수 c에 저장된 문자를 출력한다.            |

### 1. getchar()과 putchar()

```c
int getchar(void); // 하나의 문자를 입력받는다. (버퍼 사용)
int putchar(int c); // 하나의 문자를 출력한다.
```

* stdio.h를 포함해야한다.
* getchar()은 함수의 반환형이 int형인 이유는 입력의 끝을 나타내는 EOF(End Of File)문자를 체크하기 위해서이다.

### 2. _getch()과 _putch()

```c
int _getch(void); // 하나의 문자를 입력받는다. (에코(화면출력)X, 버퍼X)
int _putch(int c); // 하나의 문자를 출력한다. (에코(화면출력)X, 버퍼X)
```

* conio.h를 포함해야 한다.

* 문자 하나를 입력하면 바로 프로그램으로 전달된다.

* 에코가 필요한 경우 _getche를 사용할 수 있다.

### 표

|           | 헤더 파일 | 버퍼 사용 여부 | 에코 여부 | 응답성    | 문자 수정 여부 |
| --------- | --------- | -------------- | --------- | --------- | -------------- |
| getchar() | <stdio.h> | 사용함(엔터)   | 에코 O    | 줄 단위   | 가능           |
| _getch()  | <conio.h> | 사용 X         | 에코 X    | 문자 단위 | 불가능         |
| _getche() | <conio.h> | 사용 X         | 에코 O    | 문자 단위 | 불가능         |

<br>

## 12.3 문자열 입출력 라이브러리

문자열을 입출력하는 것으 아주 많이 사용되는 기능이다.

| 입출력 함수             | 설명                                                |
| ----------------------- | --------------------------------------------------- |
| int scanf("%s", s)      | 문자열을 읽어서 문자 배열 s[]에 저장                |
| int printf("%s", s)     | 배열 s[]에 저장되어 있는 문자열을 출력한다.         |
| char *gets(char *s)     | 한 줄의 문자열을 읽어서 문자 배열 s[]에 저장한다.   |
| int puts(const char *s) | 배열 s[]에 저장되어 있는 한 줄의 문자열을 출력한다. |

### 1. gets()와 puts()을 이용한 문자열 입출력

```c
char *gets(char *buffer); // 사용자로부터 한 줄을 입력받는다.
int puts(const char *str); // 한 줄을 출력한다.
```

* gets()는 줄바꿈 문자가 나올때 까지 한 줄의 라인을 문자열로 입력받는다.
  * scanf()는 한 단어밖에 받지 못한다.
  * gets()는 줄바꿈문자(\n)를 포함하지 않는 대신 NULL(\0)을 추가한다.
  * gets()는 <u>배열의 크기를 넘어서면 다른 자료를 덮어쓸 수 있다.</u>
    * gets_s()는 지정된 개수 이상이 입력되면 입력을 중지한다.

* puts()는 str이 가리키는 문자열을 받아서 화면에 출력하는 함수이다.
  * 문자열 끝에 있는 NULL(\0)대신에 줄바꿈문자(\n)로 변경된다.
  * 출력이 성공하면 음수가 아닌 값이 반환되고, 실패하면 EOF이 반환된다.
* gets()와 puts()는 scanf() printf()보다 간단해서 속도면에서 유리하고, 한줄 전체를 받을 수 있다는 장점 때문에 사용한다.

<br>

## 12.4 문자 처리 라이브러리

문자를 처리하는 함수는 많은 사람들이 필요로 하므로 라이브러리로 제공된다.

* 문자들을 검사하거나 대문자를 소문자로 변환시키는 함수들을 포함한다.

* ctype.h 헤더파일에 정의되어 있다.

* 문자를 검사하는 함수는 is로 시작하고 거짓이면 0을 반환하고 참이면 0이 아닌 값을 반환한다.

  | 함수        | 설명                                              |
  | ----------- | ------------------------------------------------- |
  | isalpha(c)  | c가 영문자인가? (a-z, A-Z)                        |
  | isupper(c)  | c가 대문자인가? (A-Z)                             |
  | islower(c)  | c가 소문자인가? (a-z)                             |
  | isdigit(c)  | c가 숫자인가? (0-9)                               |
  | isalnum(c)  | c가 영문자이나 숫자인가? (a-z, A-Z, 0-9)          |
  | isxdigit(c) | c가 16진수의 숫자인가? (0-9, A-F, a-f)            |
  | isspace(c)  | c가 공백 문자인가? ('  ', '\n', '\t', '\v', '\r') |
  | ispunct(c)  | c가 구두점 문자인가?                              |
  | isprint(c)  | c가 출력 가능한 문자인가?                         |
  | isprint(c)  | c가 출력 가능한 문자인가?                         |
  | isascii(c)  | c가 아스키 코드인가?                              |

* 문자 변환 함수는 to로 시작하고 int형 인수를 받고 반환형도 int형이다.

  | 함수       | 설명                      |
  | ---------- | ------------------------- |
  | toupper(c) | c를 대문자로 바꾼다.      |
  | tolower(c) | c를 소문자로 바꾼다.      |
  | toascii(c) | c를 아스키 코드로 바꾼다. |

## 12.5 문자열 처리 라이브러리 함수

문자열을 사용하다보면 두 개의 문자열을 붙이는 작업이나 두 개의 문자열을 서로 비교하는 작업들이 필요해진다. 그래서 라이브러리 함수가 제공된다.

* string.h 헤더파일에 정의되어 있다.

* 문자열 처리 라이브러리는 상당히 복잡하기 때문에 기초적인 몇가지만 표로 정리했다.

  | 함수                     | 설명                                             |
  | ------------------------ | ------------------------------------------------ |
  | strlen(s)                | 문자열 s의 길이를 구한다.                        |
  | strcpy(s1, s2)           | s2를 s1에 복사한다.                              |
  | strcat(s1, s2)           | s2를 s1끝에 붙여넣는다.                          |
  | strcmp(s1, s2)           | s1과 s2를 비교한다.                              |
  | strncpy(s1, s2, n)       | s2의 최대 n개의 문자를 s1에 복사한다.            |
  | strncat(s1, s2, n)       | s2의 최대 n개의 문자를 s1의 끝에 붙여넣는다.     |
  | strncmp(s1, s2, n)       | 최대 n개의 문자까지 s1과 s2를 비교한다.          |
  | strchr(s, c)             | 문자열 s 안에서 문자 c를 찾는다.                 |
  | strstr(s1, s2)           | 문자열 s1안에서 문자열 s2를 찾는다.              |
  | char *strtok(s, delimit) | 문자열 s를 delimit를 이용하여 토큰으로 분리한다. |

#### 문자열 길이

* strlen()

  ```c
  size_t strlen( const char *s ); // const는 매개 변수를 통해 원본을 변경하지 않음을 의미하고, 문자 배열을 포인터로 받는다.
  //문자열의 길이를 반환한다. NULL 문자는 제외된다.
  size = strlen("Hello"); // 5를 반환한다.
  ```

#### 문자열 복사

* strcpy()

  ```c
  char *strcpy( char *dst, const char *src ); // 두 인수는 char포인터이다.
  //src를 dst로 복사한다. 문자열의 복사는 한글자씩 순차적으로 이루어진다.
  char dst[6];
  char src[6] = "Hello";
  strcpy(dst, src); // "Hello"가 dst로 복사된다.
  ```

  * dst의 문자열의 길이가 src의 문자열의 길이보다 길거나 같아야 한다.

  * strcpy()의 보다 안전한 버전

    ```c
    strcpy_s(char *dst, size_t size);
    ```

  * 복사할 문자의 개수를 제한하려면 srtncpy()를 사용하면 된다.

    ```c
    char *strncpy( char *dst, const char *src, size_t n);
    // src를 dst로 n개의 문자만을 복사한다.
    strncpy(dst, "Hello", 3); // "Hel"만 복사된다.
    ```

    * n보다 src 문자열의 길이가 작으면 전체 src 문자열이 복사된다.

#### 문자열 연결

* strcat()

  ```c
  char *strcat(char *dst, const char *src);
  //src를 dst에 붙인다.
  char dst[12] = "Hello";
  char src[6] = "World";
  strcat(dst, src); // dst가 "HelloWorld"가 된다.
  ```

  * 만약 dst 배열에 src를 연결할 충분한 공간이 없다면 문제가 발생한다.

  * 연결할 문자열의 개수를 제한하려면 strncat()을 사용하면 된다.

    ``` c
    char *strncat( char *dst, const char *src, size_t n );
    // src의 n개의 문자만을 dst에 붙인다. strncat() 함수는 src 문자열 중에서 최대 n개의 문자만 dst에 연결한다.
    char dst[12] = "Hello";
    char src[6] = "World";
    strcat(dst, src, 3); // dst가 "HelloWor"가 된다.
    ```

    * n보다 src 문자열의 길이가 작으면 전체 src 문자열이 복사되어 연결된다.

#### 문자열 비교

* strcmp()

  ```c
  char *strcmp( const char *s1, const char *s2 );
  //strcmp()는 문자열 s1과 s2를 비교하여 Ascii Code순서에 따라 s1이 앞에 있으면 음수가 반환되고, 같으면 0이, 뒤에 있으면 양수가 반환된다.
  strcmp("dog", "dog"); // 0을 반환
  strcmp("cat", "dog"); // 음수 반환
  strcmp("dog", "cat"); // 양수 반환
  ```

  * strcmp는 아스키 코드 값을 차례대로 비교하고 코드 값이 같다면 계속해서 다음 문자들을 비교한다.
    * 코드 값이 다르다면 음수나 양수를 반환한다.
    * 코드 값이 모두 같으면 0을 반환한다.

#### 문자 검색

* strchr()

  ```c
  char *strchr( const char *str, int c);
  // 함수 strchr()는 주어진 문자열 str에서 문자 c를 검색하여 그 주소를 반환한다.
  ```

  * strchr()은 문자열 str의 첫 번째 문자부터 차례대로 검색해나가다가 문자 c를 찾으면 그 주소를 반환한다.
    * 없으면  NULL을 반환함

* strrchr()

  * strchr()과는 다르게 검색하는 방향이 반대이다.

#### 문자열 검색

* strstr()

  ```c
  char *strstr( const char *s, const char *sub);
  //strstr() 함수는 문자열 s 안에서  부분 문자열(substring) sub를 검색하는 함수이다.
  ```

  * 만약 부분 문자열이 발견되면 그 위치의 주소를 반환한다.
    * 부분 문자열을 찾지 못하면 NULL 값을 반환한다.

#### 문자열 토큰 분리

* strtok()

  ```c
  char *strtok( char *s, const char *delimit);
  // strtok 함수는 문자열 s를 토큰으로 분리한다.
  t1 = strtok(s, " "); // 첫 번째 토큰
  t2 = strtok(NULL, " "); // 두 번째 토큰
  t3 = strtok(NULL, " "); // 세 번째 토큰
  t4 = strtok(NULL, " "); // 네 번째 토큰
  ```

  * 분리자를 여러개로 지정하려면 문자들을 모아서 문자열로 만들면 된다.

    ```c
    seps[] = " ,\t\n"; // 스페이스, 쉼표, 탭 문자, 줄바꿈 문자를 분리자로 사용
    ```

## 12.6 문자열 수치 변환

문자열과 실수는 메모리에 저장하는 방식이 다르다.

```c
double a = 36.5; // %a부터 8byte값을 읽으면 36.5 라는 실수값이 변수에 저장된다.
char A[] = "36.5"; // A부터 순서대로 인덱스에 3, 6, ., 5값이 순서대로 대입된다.
```

문자열을 실수로 바꾸기 위한 몇가지 방법이 존재한다.

### 1. sscanf()와  sprintf()

이들 함수는 scanf()와 printf() 앞에  s를 붙인 것으로 s는 문자열(string)을 의미한다.

* sscanf() 함수 사용

  ``` c
  sscanf(s, ...); // 문자열 s로부터 지정된 형식으로 수치를 읽어서 변수에 저장한다.
  sscanf(s1, "%d", &value); // 문자열에서 %d형식으로 읽어서 value에 저장한다.
  ```

  * **문자열 → 수치로 변환**

* sprintf() 함수 사용

  ```c
  sprintf(s, ...); // 변수의 값을 형식 지정자에 따라 문자열 형태로 문자 배열 s에 저장한다.
  sprintf(s2, "%d", value); // value에 저장된 값을 형식 지정자에 따라 문자열 형태로 변환하여 s2에 저장한다.
  itoa(value, s2, 10) // sprintf()와 같은 의미, 끝의 10은 10진수를 의미한다.
  ```

  * **수치 → 문자열로 변환**

### 2. 전용 함수 사용

간단하게 문자열을 정수나 실수로 변환하는 경우, 전용함수를 사용하는 것도 바람직하다.

문자열을 수치값으로 변환하는 전용 함수로는 atoi(), atof()가 있다.

함수는 stdlib.h에 포함되어 있다.

#### atoi()

```c
int atoi( const char *str ); // str을 int형으로 변환한다.
```

#### atof()

```c
double atof( const char *str ); // str을 double형으로 변환한다.
```

## 12.7 문자열의 배열

문자열의 배열을 2차원의 배열을 통해서 구현할 수 있다.

```c
char s[3][6] = {
    "init",
    "open",
    "close"
};
```

* 문자열의 개수를 지정하지 않으면 초기화시에 주어진 문자열의 개수가 2차원 배열의 행의 크기가 된다.

  ```c
  char s[][6] = {
      "init",
      "open",
      "close"
  };
  ```

* 2차원 배열  s의 각각의 행은 s[0], s[1], s[2]와 같이 접근할 수 있다.

  ```c
  printf("%s", s[0]);
  ```

### 포인터 배열

문자열의 길이가 서로 다르면 길이가 짧은 문자열이 저장된 행은 낭비되는 공간이 많아진다.

포인터의 개념을 사용해서 메모리의 낭비를 막을 수 있다.

```c
char *error_msg[3] = { //3개의 포인터를 가지는 배열 설정
    "fatal",
    "open error",
    "close error"
}
```

* 각 포인터는 메모리에 저장된 문자열 상수의 주소를 가지고 있다. 문자열 상수는 문자열의 크기만큼만 자리를 차지한다.
  * **포인터 배열을 사용하면 한번 문자열이 결정되면 문자열의 내용을 바꿀 수 없다.**
    * 문자열 상수로 선언되기 때문

